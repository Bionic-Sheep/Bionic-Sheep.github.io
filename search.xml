<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022.4.2 京东笔试</title>
    <url>/4.2%E4%BA%AC%E4%B8%9C%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<p>第一题：</p>
<p>在满二叉树上行走，U上L左R右</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/输入描述</span><br><span class="line"><span class="comment">//第一行两个空格隔开的正整数N，X</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//接下来一行一个长度为N的只包含U,L,R三种字母的字符串。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//对于90%的数据，1≤N≤100，1≤X＜210</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//对于100%的数据，1≤N≤5.105，1≤X＜230</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        String str;</span><br><span class="line">        <span class="type">long</span> n; <span class="comment">//路径</span></span><br><span class="line">        <span class="type">long</span> x;<span class="comment">//所在节点编号</span></span><br><span class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">            n = in.nextInt();</span><br><span class="line">            x = in.nextInt();</span><br><span class="line">            str = in.next();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i); <span class="comment">//拿到当前行走命令</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//左孩子是 2*x 右孩子是 2*x+1</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;U&#x27;</span> || c ==<span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    x = (<span class="type">long</span>)x / <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span> || c == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">//向右走</span></span><br><span class="line">                    x = (<span class="type">long</span>)(<span class="number">2</span> * x + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    x = (<span class="type">long</span>)(<span class="number">2</span> * x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(x);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题只过了0.91，难点就在于避免超时，一开始x的接受没有用long，只能过55，后面仔细阅读题目才发现，数据范围很大，改为long，但还是有一例数据难过，可能是字符串导致的超时。</p>
<p>第二题</p>
<p>粉刷匠：不是很理解题意，但是最多的次数为3，我判断失误，只过了0.09，但是可以先判断是否相等，相等为0,不等输出rand()mod3+1，可以得到0.81，大失误。</p>
]]></content>
  </entry>
  <entry>
    <title>ArrayList和LinkedList</title>
    <url>/ArrayList%E5%92%8CLinkedList/</url>
    <content><![CDATA[<p>Collection接口的常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>; <span class="comment">// 向集合中添加一个元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection c)</span>; <span class="comment">//添加集合中的所有元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span>; <span class="comment">//清理集合中所有元素，集合长度为0</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>; <span class="comment">//判断集合中是否存在指定元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>; <span class="comment">// 判空</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>; <span class="comment">//删除指定元素，当集合包含多个元素o，值删除第一个符合条件的元素。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">Object[] toArray();<span class="comment">//转换为响应的数组</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">()</span>; <span class="comment">//保留集合中相同的元素，其余删除</span></span><br></pre></td></tr></table></figure>



<p><strong>重点</strong></p>
<p>排序操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List list)</span>; <span class="comment">//反转</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List list)</span>;<span class="comment">//随机排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list)</span>;<span class="comment">//按自然排序升序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list, Comparator c)</span>; <span class="comment">//定制排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List list, <span class="type">int</span> i, <span class="type">int</span> j)</span>;<span class="comment">//交换两个索引位置的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List list, <span class="type">int</span> distance)</span>; <span class="comment">//旋转，当distance为正数，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span><br></pre></td></tr></table></figure>



<p>查找、替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span><br></pre></td></tr></table></figure>





<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>有序、可重复的集合。</p>
<p>实现类：ArrayList和LinkedList</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>实现可变数组大小，<strong>快速基于索引访问元素的方式，即随机访问，</strong>删除和插入元素相对较慢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;<span class="comment">//获取index下标元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">index</span><span class="params">(Object o)</span>; <span class="comment">//返回第一次出现指定元素的索引 不存在返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>; <span class="comment">//返回最后一次出现指定元素的索引 不存在返回-1</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>; <span class="comment">//将此索引位置元素修改为elements参数指定的对象</span></span><br><span class="line">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>; <span class="comment">//返回两个参数索引之间的所有元素</span></span><br></pre></td></tr></table></figure>



<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>采用链表保存对象，便于向<strong>集合中插入或者删除元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>; <span class="comment">//将指定元素添加到此集合的开头</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>; <span class="comment">//将指定元素添加到此集合的末尾</span></span><br><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>; <span class="comment">//返回首元素</span></span><br><span class="line">E <span class="title function_">getLast</span><span class="params">()</span>; <span class="comment">//返回尾元素</span></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span>; <span class="comment">//删除首元素</span></span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span>; <span class="comment">//删除为元素</span></span><br></pre></td></tr></table></figure>



<h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3><p>都是List接口的实现类，都实现了List的方法，只是实现的方式不同。</p>
<p>ArrayList是基于动态数组数据结构实现的，在元素访问上更胜一筹，因为数组在内存上的存储是连续的，但是链表是离散的，需要根据上下游标去查询</p>
<p>LinkedList是基于链表数据结构实现的，占用内存空间大，但在删除和增加元素上更好，可扩展性更好。</p>
]]></content>
  </entry>
  <entry>
    <title>2022.4.2 360笔试</title>
    <url>/4.2360%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<p>第一题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断字符串串是否对称</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;*/</span><br><span class="line">       <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">	   <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;T&#x27;</span>,<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;V&#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>&#125;;                                            </span><br><span class="line">       <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            str = in.nextLine();</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : ch)&#123;</span><br><span class="line">                map.put(c,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : str.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(c))&#123;</span><br><span class="line">                    k = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(k == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right= str.length()-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(str.charAt(left) != str.charAt(right))&#123;</span><br><span class="line">                        k = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">1</span>) System.out.println(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//吃鸡组队</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        t = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> a, b, c, d;</span><br><span class="line">            a = in.nextInt();</span><br><span class="line">            b = in.nextInt();</span><br><span class="line">            c = in.nextInt();</span><br><span class="line">            d = in.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//首先将四人队补充完整</span></span><br><span class="line">            ans += d;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a &gt;= c) &#123;</span><br><span class="line">                <span class="comment">//单人队的数量超过三人队，可全部扩充为四人队</span></span><br><span class="line">                ans += c;</span><br><span class="line">                a -= c;</span><br><span class="line">                c = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += a; <span class="comment">//</span></span><br><span class="line">                a = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans += b / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//两人队也没了</span></span><br><span class="line">                b = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//现在的情况是d == 0, c != 0 则a == 0, c == 0,说明a还剩</span></span><br><span class="line">            <span class="comment">//如果a很多的情况，可能存在浪费</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                        ans += <span class="number">1</span>;</span><br><span class="line">                        a -= <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans += a/<span class="number">4</span>;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure>



<p>情况：两道题都挺简单的，都AC了，第一种反转字符串，只要排除掉非对称字符即可，第二题和leetcode上面找零钱非常类似，核心就是5美元的数量，对应到本题就是单人队的数量，以单人队来补充bc队的人数。</p>
<p>代码可读性很差， 因为在时间紧张的条件下，不会在意代码的优美。</p>
]]></content>
  </entry>
  <entry>
    <title>comparable 和 comparator</title>
    <url>/comparable%20%E5%92%8C%20comparator/</url>
    <content><![CDATA[<h1 id="Comparable接口的-自然排序"><a href="#Comparable接口的-自然排序" class="headerlink" title="Comparable接口的 - 自然排序"></a>Comparable接口的 - 自然排序</h1><ol>
<li>像String 、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式<ul>
<li>重写compareTo(obj)规则</li>
</ul>
</li>
<li>对于自定义类来说，如果需要排序：<ul>
<li>首先实现 Comparable接口</li>
<li>其次重写CompareTo(obj)方法</li>
</ul>
</li>
</ol>
<p>//String、包装类的排序：不需要自己重写compareTo(obj)方法。类已经写好了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;KK&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;GG&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>//自定义类：需要自己重写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">4</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;xiaomi&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huawei&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenven&quot;</span>,<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//省略类的属性、构造方法、getset方法</span></span><br><span class="line">        </span><br><span class="line">     <span class="comment">//重写compareTo(obj)方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( o <span class="keyword">instanceof</span>  Goods)&#123;<span class="comment">//强转</span></span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span>(Goods)o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//返回正数 goods更大</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二</span></span><br><span class="line">   <span class="comment">//          return Double.compare(this.price, goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>alt ＋ insert 可以插入构造器。get set toString equals等方法</p>
<h2 id="Comparato接口-定制排序"><a href="#Comparato接口-定制排序" class="headerlink" title="Comparato接口-定制排序"></a>Comparato接口-定制排序</h2><ol>
<li>背景：当元素的类型没有实现java.lang.Comparable接口但又不方便修改代码，或者当前接口的排序规则不符合当前操作，就使用Comparato的对象来排序</li>
<li>重写compare(Object o1, Object o2)方法，比较o1和o2的大小：如果方法返回正整数，o1 大于 o2; 0 则相等 否则o1 小于 o2</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;KK&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;GG&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123; <span class="comment">//自定义排序</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//按照字符串从大到小排序</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span>  String &amp;&amp; o2 <span class="keyword">instanceof</span> String)&#123;<span class="comment">//强转数据类型</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String) o1;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> (String) o2;</span><br><span class="line">                    <span class="keyword">return</span> -s1.compareTo((s2));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入类型不一致！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">6</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;xiaomi&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huawei&quot;</span>, <span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenven&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenven&quot;</span>,<span class="number">223</span>);</span><br><span class="line">        arr[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenven1&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Goods&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按照产品名称从低到高排序，再按价格从高到低</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Goods o1, Goods o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span>  Goods &amp;&amp; o2 <span class="keyword">instanceof</span>  Goods)&#123;</span><br><span class="line">                    <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods) o1;</span><br><span class="line">                    <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods) o2;</span><br><span class="line">                    <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                        <span class="comment">//品牌一样</span></span><br><span class="line">                        <span class="keyword">return</span> -Double.compare(g1.getPrice(), g2.getPrice());</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> g1.getName().compareTo((g2.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;数据类型输入错误！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Java中的Integer的长度判断</title>
    <url>/Java%E4%B8%AD%E7%9A%84Integer%E7%9A%84%E9%95%BF%E5%BA%A6%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h1 id="Java中的Integer的长度判断"><a href="#Java中的Integer的长度判断" class="headerlink" title="Java中的Integer的长度判断"></a>Java中的Integer的长度判断</h1><p>Java的数据类型是两种：</p>
<ol>
<li>基本数据类型:int, double…..等</li>
<li>引用类型：Integer，Double等</li>
</ol>
<p>一般比较大小有两种，要么==，要么equals。</p>
<p>==在比较基本数据类型时，是数值大小，比较引用类型时，是比较两个引用对象是否相等。</p>
<p>只有equals，不管是基本数据类型还是引用数据累心，都比较的是数值大小（或者重写equals方法的内容），所以我们在比较引用类型对象的数值大小时，尽量采用equals。</p>
<p>下面给个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>, b = <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">// true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">127</span>, d = <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">128</span>, b = <span class="number">128</span>;</span><br><span class="line">System.out.println(a == b);<span class="comment">// true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">128</span>, d = <span class="number">128</span>;        </span><br><span class="line">System.out.println(a == b); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>出现上面情况是因为Integer将[-128,127]范围的整数都提前实例化了，只要数值相等，==比较的都是同一个对象。我们可以用Integer.intValue转为基本数据类型，或者equals来比较</p>
<p>提前实例化：Integer作为常量时，对于-128到127之间的数，会进行缓存，也就是说int a1 = 127时,在范围之内，这个时候就存放在缓存中，当再创建a2时，java发现缓存中存在127这个数了，就直接取出来赋值给a2，所以a1 == a2的。当超过范围就是new Integer()来new一个对象了，所以c、d都是new Integer(128)出来的变量，所以它们不等。</p>
]]></content>
  </entry>
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <url>/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p><img src="https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220403210457.png" alt="运行时数据区"></p>
<h2 id="什么是Java字节码？"><a href="#什么是Java字节码？" class="headerlink" title="什么是Java字节码？"></a>什么是Java字节码？</h2><p>Java源代码经过编译器编译后产生的文件，只面向虚拟机。这也是Java跨平台性的原因，一次编译到处运行。在虚拟机上执行。</p>
<p><strong>优点</strong>：字节码不针对特定机器，只面向虚拟机执行，因此不用重新编译就可以在不同的计算机上运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java源码--&gt;编译--&gt;字节码.class文件，即JVM可执行的Java字节码--&gt;JVM--&gt;JVM解释器--&gt;二进制码--&gt;程序运行</span><br></pre></td></tr></table></figure>

<h1 id="Java的内存区域"><a href="#Java的内存区域" class="headerlink" title="Java的内存区域"></a>Java的内存区域</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ol>
<li>当前线程所执行字节码的行号指示器，程序的基础功：分支、循环、跳转都依赖它</li>
<li>为什么需要程序计数器？ 因为Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式实现的，一个处理器执行一条线程指令，为了在线程切换后恢复到正确的执行位置，每个线程需要一个独立的程序计数器</li>
<li>线程执行Java方法：记录虚拟器字节码指令地址，本地方法：值为空</li>
</ol>
<h2 id="虚拟机栈-本地方法栈"><a href="#虚拟机栈-本地方法栈" class="headerlink" title="虚拟机栈|本地方法栈"></a>虚拟机栈|本地方法栈</h2><p>创建一个线程就会创建一个虚拟机栈，每个方法被执行或调用时，就会创建一个栈帧放入虚拟机栈中，存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。每个方法被调用完，就对应了一个栈帧入栈到出栈的过程。</p>
<p>本地方法栈执行的是本地方法，作用和虚拟机栈类似</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>线程共享的一块区域，在虚拟机启动时创建，唯一目的是<strong>存放对象实例</strong>。</p>
<p>垃圾收集在堆上进行，也被称为GC堆，物理上可以不连续，但逻辑上连续，可固定可扩展</p>
<p>注：具体的堆在后面会讲解</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>线程共享的一块区域，存储被被虚拟机加载的信息：常量、静态变量、即时编译器、编译后的代码缓存等。</p>
<h1 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h1><p>以HotSpot为例</p>
<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p><img src="https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220403210549.png" alt="对象创建"></p>
<p>遇到一个字节码new指令，先检查指令能否在<strong>常量池</strong>中定位到<strong>类的符号引用</strong>，再检查引用是否被类加载、解析、初始化。如果无，则执行类加载过程</p>
<h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>将一块<strong>确定大小的内存块</strong>从Java堆中划分：指针碰撞和空闲列表</p>
<p>分配方式：Java堆是否规整决定的，是否规整由垃圾收集器决定，是否带有压缩整理功能。</p>
<ol>
<li>指针碰撞：以指针为分界点，一边是空闲的内存区域，一边是使用过的内存区域。GC收集器：Serial、ParNew</li>
<li>空闲列表：虚拟机维护一个列表，记录那个区域是可用的，分配时，从列表找到一块够用的区域来划分。GC收集器：CMS基于清除算法。</li>
<li>内存分配并发问题：</li>
</ol>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>分配完毕，将分配到的内存区域初始化为零值（不包括对象头），保证<strong>对象的实例字段在Java代码中不需要赋值就能够使用</strong></p>
<h2 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h2><p>设置对象是那个类的实例、如何找到类的元数据信息，对象的哈希码、对象的GC分代年龄。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>经历上面四步，虚拟机认为对象已经创建完毕，接下来是按照Java程序的意图，执行构造函数，完成初始化。</p>
<h1 id="对象的内存布局与访问定位"><a href="#对象的内存布局与访问定位" class="headerlink" title="对象的内存布局与访问定位"></a>对象的内存布局与访问定位</h1><h2 id="内存布局："><a href="#内存布局：" class="headerlink" title="内存布局："></a>内存布局：</h2><p>对象头、实例数据、对齐填充</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><ol>
<li><strong>存储自身运行时数据</strong>：哈希码，GC分代年龄，锁状态标志、线程持有锁、偏向线程ID、偏向时间戳</li>
<li>类型指针，可以通过该<strong>指针知道该对象是哪个类的实例</strong>。</li>
</ol>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>存储对象真正有效的数据，在程序代码中定义的各种类型的字段内容。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>占位符作用，实例数据没有补充完成，需对齐</p>
<h2 id="访问定位"><a href="#访问定位" class="headerlink" title="访问定位"></a>访问定位</h2><p>通过栈上的reference数据来操作堆上的数据</p>
<p><strong>对象实例数据</strong>（堆）:对象中各个实例字段的数据</p>
<p><strong>对象类型数据</strong>（方法区）：对象的类型、父类、实现的接口、方法等</p>
<h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>Java堆中有一块内存作为句柄池，reference存放的就是对象的句柄地址，包含了对象<strong>实例数据</strong>和<strong>类型数据</strong>各自的地址信息。</p>
<p><strong>优点</strong>：稳定的句柄地址，移除对象值会改变句柄中的实例数据，不改变reference</p>
<p><strong>缺点</strong>：两次指针移动</p>
<p><img src="https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220403210600.png" alt="对象的访问定位-使用句柄.53859387.png"></p>
<h3 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h3><p>Java堆中对象的内存布局必须考虑如何放置访问类型数据的相关信息，reference中<strong>存储的直接就是对象的地址</strong>。</p>
<p>好处：访问速度快，节省指针开销</p>
<p><img src="https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220403210613.png" alt="对象的访问定位-直接指针.c3bbe790.png"></p>
]]></content>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>二分查找是一个高效率的查找方法，通常应用在顺序存储结构，且关键字有序。</p>
<p>查找过程：</p>
<ol>
<li>将搜索空间中间的数mid与target比较</li>
<li>当mid数小于target说明target在搜索空间右边，将[mid+1-right]作为搜索空间，当mid数大于target说明target在搜索空间左边，将left-mid-1作为搜索空间。</li>
<li>重复1.2步骤，直至发现target或搜索空间为0</li>
</ol>
<p>核心思想：不断的缩短搜索空间来寻值。</p>
<h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p><strong>左闭右闭</strong>和<strong>左闭右开</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="comment">//最简单的模板</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(left &lt;= right)&#123; <span class="comment">// [left, right]</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">               right = mid -<span class="number">1</span>; <span class="comment">//nums[mid]参与了运算，即[left, mid]结束搜索，下一个搜索空间为[mid+1,right]</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               left = mid + <span class="number">1</span>; <span class="comment">//同理,[mid, right]结束搜索，下一个搜索空间为[left, mid-1]</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> ,right = nums.length;</span><br><span class="line">       <span class="keyword">while</span>(left &lt; right)&#123; <span class="comment">//[left, right)，因为right = nums.length 表示nums[right]是不存在的数</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">               left = mid + <span class="number">1</span>; <span class="comment">// nums[mid]参与运算，即[left, mid]结束搜索，下一个[mid+1, right)</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               right = mid; <span class="comment">//同理，[mid,right)结束，下一个搜索空间是[left, mid-1],这里为了保持左闭右开的一致性，用right表示mid-1，即[left, mid-1] == [left, mid) == [left, right)</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>之前不太明白左闭右开的搜索逻辑，但是在LC上看了大佬liweiwei1419的文章后才算是豁然开朗。</p>
<p>下面给出我做的几个二分查找LC题</p>
<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></h2><p>这题算是第三个模板，只有两个判断，同过不断缩短搜索空间，最后left == right跳出循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">//首先弄懂它查找的值在数组中的实际意义，找到target第一次大于等于元素的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123; <span class="comment">//当left和right重合，停止搜索，即left是大于或等于的元素下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//[left, mid] 小于它 [mid+1, right)</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid; <span class="comment">//[mid, right)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftBorder</span> <span class="operator">=</span> getLeftBorder(nums, target);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rightBorder</span> <span class="operator">=</span> getRightBorder(nums, target);</span><br><span class="line">    <span class="keyword">if</span>(leftBorder == -<span class="number">2</span> ||  rightBorder == -<span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;; <span class="comment">//因为它不但向一边逼近</span></span><br><span class="line">    <span class="keyword">if</span>(rightBorder - leftBorder &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftBorder+<span class="number">1</span>, rightBorder-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftBorder</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="comment">//寻找左边界,即重复元素第一个，那么右边不断向左缩短即可</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= target)&#123; <span class="comment">//因为是右边不断向左缩小，那么必然有相等的情况</span></span><br><span class="line">            right = mid; <span class="comment">// [mid, right) --&gt; [left, mid-1] -- &gt;[left, mid) </span></span><br><span class="line">            ans = right - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//[left, mid] --&gt; [mid+1, right]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightBorder</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="type">int</span> ans= -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt;= target)&#123; <span class="comment">//，如果不存该数，例如nums = [5,7,7,8,8,10], target = 6，那么不会进入下面语句</span></span><br><span class="line">            <span class="comment">//左边向右逼近，</span></span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">////[left, mid] --&gt; [mid+1, right]</span></span><br><span class="line">            ans = left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根 </a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// 有序，找值，k² &lt;= x 中k的最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = x; <span class="comment">//这里不能x/2，因为x/2，因为奇偶数不同，奇数除2会向下取整数，所以成闭区间，偶数又是开区间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>((<span class="type">long</span>)mid*mid &lt;= x)&#123;</span><br><span class="line">            <span class="comment">//应该是向右逼近，</span></span><br><span class="line">            ans = mid; <span class="comment">//ans记下当前满足条件的k</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a><a href="https://leetcode-cn.com/problems/valid-perfect-square/">367. 有效的完全平方数</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">       <span class="comment">//和x一样</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = num;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right-left)/<span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid*mid &lt;= num)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans*ans == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面部分我基本只写了两种判断就是为了锻炼分析搜索空间的能力。一定要记住核心思想：<strong>不断的减小搜索空间</strong>。</p>
<p>解题首要要判断我们到底要找的是什么样的值，有哪些特征。</p>
<p>比如说35.搜索插入位置，我们要找到值是一个大于等于target的元素下标。</p>
<p><em>当前左边所有的搜索空间均小于它，那么反过来，随着搜索空间的减小，mid+1是不是最终就大于等于target</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] &lt; target)&#123; </span><br><span class="line">   left = mid + <span class="number">1</span>; <span class="comment">//[left, mid] 小于它 [mid+1, right)</span></span><br></pre></td></tr></table></figure>

<p><em>同理,右边所有的搜索空间均大于等于它，那么最终left == right的时候，right就停在了大于等于target的元素下标的位置</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123; </span><br><span class="line">    right = mid; <span class="comment">//[mid, right)</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>所以最后返回 left或right均可。</p>
<p>34,69,367问题都是类似，都是找元素下标，34左边找第一个target下标，右边找最后一个target下边，69和367是一样的问题，34找k²&lt;=x的最大值k,367找k²==x。都是逐步减小搜索空间，然后逼近。仔细体会</p>
]]></content>
  </entry>
  <entry>
    <title>hexo + github 显示404 There isn&#39;t a GitHub Pages site here.</title>
    <url>/hexo%20+%20github%20%E6%98%BE%E7%A4%BA404%20There%20isn&#39;t%20a%20GitHub%20Pages%20site%20here/</url>
    <content><![CDATA[<p>我是按照<a href="https://www.nowcoder.com/discuss/657562?type=0&amp;order=7&amp;pos=8&amp;page=1&amp;channel=1009&amp;source_id=discuss_center_0_nctrack">https://www.nowcoder.com/discuss/657562?type=0&amp;order=7&amp;pos=8&amp;page=1&amp;channel=1009&amp;source_id=discuss_center_0_nctrack</a> 这篇文章来搭建博客的，在部署的过程中一直显示错误，最后</p>
<p><img src="https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220322171305.png" alt="image-20220320125619898"></p>
<p>在这反应过来了，这里的意思应该是你github的用户名，我的用户名叫bionic-sheep，但是我的仓库名叫sheep。</p>
<p>最后在<img src="https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220322171308.png" alt="image-20220320125846531"></p>
<p>这个地方改过来之后就好了。</p>
<p>刚好当做博客的第一篇博文</p>
]]></content>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>不断的调节子序列的起始位置和终止位置，得到我们想要的结果。</p>
<p>一般的模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(枚举选择)</span><br><span class="line">	右边界</span><br><span class="line">	<span class="keyword">while</span>(窗口条件)</span><br><span class="line">		左边界</span><br><span class="line">		更新结果</span><br></pre></td></tr></table></figure>

<p>下面给出一种更常用的模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.需要维护的变量，长度大小，数和，哈希表等</span></span><br><span class="line"><span class="type">int</span> sum, Map。。。</span><br><span class="line"><span class="comment">//2.定义首尾端</span></span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line"><span class="comment">//3.更新维护的变量</span></span><br><span class="line">sum +=, map.put.. </span><br><span class="line"></span><br><span class="line"><span class="comment">//4.下面有两种情况，一种是长度可变的窗口，一种是长度固定的窗口</span></span><br><span class="line"><span class="comment">//4.1长度可变，一般是在3更新维护变量时，破坏了窗口的合法性，</span></span><br><span class="line"><span class="comment">//需要在while中，更改维护的变量并且左移指针来恢复窗口的合法性</span></span><br><span class="line"><span class="keyword">while</span>(长度可变)&#123;</span><br><span class="line">	sum -= nums[left];</span><br><span class="line">	left++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.2长度不可变，一般是在满足条件后，用if判断当前窗口是否达到限定长度，</span></span><br><span class="line"><span class="comment">//然后左指针迁移一个单位，保证下次右指针右移，窗口长度不变</span></span><br><span class="line"><span class="keyword">if</span>(长度不变)&#123;</span><br><span class="line">	left++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.更新答案，一般求法都是求解窗口的最大长度，不是必要步骤，但很常见</span></span><br><span class="line">ans = Math.max(ans, right - left);</span><br><span class="line">right++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回答案</span></span><br></pre></td></tr></table></figure>

<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//滑动窗口：右边界走，满足条件在while里处理左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// step1:定义需要维护的变量，tmp，变量和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">//step2:窗口的首尾两端</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> len+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">            tmp += nums[right]; <span class="comment">//step3:更新维护的变量</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//step4情况1：窗口长度固定：用if语句判断当前窗口是否达到了限定长度，</span></span><br><span class="line">            <span class="comment">// 达到了，窗口左指针前移一个单位，来保证下一次右指针右移时，窗口长度不变，</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(tmp &gt;= target)&#123; <span class="comment">//step4情况2：窗口长度可变：当前窗口不合法，tmp和大于目标值，</span></span><br><span class="line">                <span class="comment">// 用while不断的移动左指针剔除非法元素直至窗口合法，在左指针移动前更新维护的变量</span></span><br><span class="line">                ans = Math.min(right - left, ans); <span class="comment">//因为这是求最小，left = 0, right = 0,那么最小的就是0，所以放在while里面合适</span></span><br><span class="line">                tmp -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//维护的变量，维护摘下的水果不超过2个</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; fruits.length)&#123;</span><br><span class="line">        map.put(fruits[right], map.getOrDefault(fruits[right], <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">//更新维护变量：放入水果</span></span><br><span class="line">        <span class="keyword">while</span>(map.size() &gt; <span class="number">2</span>)&#123; <span class="comment">//判断是否超过窗口条件，长度不固定，这里的窗口长度是两种水果相连的长度，不是两种水果是窗口，所以是可变的</span></span><br><span class="line">            map.put(fruits[left], map.get(fruits[left])-<span class="number">1</span>); <span class="comment">//更新维护变量</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(fruits[left]) == <span class="number">0</span>) map.remove(fruits[left]);</span><br><span class="line">            left++;  <span class="comment">//左指针左移，然后不断的更新维护变量，来破坏窗口的非法性</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(right - left + <span class="number">1</span>, ans); <span class="comment">//更新答案</span></span><br><span class="line">        right++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">//用一个map装字符，当在遍历过程中，</span></span><br><span class="line">    <span class="comment">//发现map中有这个字符，表示重复了，将左指针定位到该字符的位置，每次遍历的过程比较ans大小</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//更新维护变量        </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>; <span class="comment">//首尾</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(c))&#123; <span class="comment">//长度固定:重复子串的长度固定</span></span><br><span class="line">            left = Math.max(map.get(c), left); <span class="comment">//这里用Math.max是因为可能出现在left前的位置出现重复字符，但是left不能往左移，</span></span><br><span class="line">        &#125;</span><br><span class="line">        map.put(c, right+<span class="number">1</span>); <span class="comment">//更新维护变量</span></span><br><span class="line">        ans = Math.max(ans, right-left+<span class="number">1</span>);</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">characterReplacement</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">//难点在于：窗口条件是什么！ 总字符数 - 最多次字符数 &lt;= k 为合法</span></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];        </span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">        <span class="comment">//找最多的字符数的</span></span><br><span class="line">        arr[c - <span class="string">&#x27;A&#x27;</span>]++; <span class="comment">// 找维持窗口条件的最多次字符数</span></span><br><span class="line">        max = Math.max(max, arr[c - <span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line">        <span class="keyword">while</span>(right - left + <span class="number">1</span> - max &gt; k)&#123; <span class="comment">//长度可变</span></span><br><span class="line">            arr[s.charAt(left) - <span class="string">&#x27;A&#x27;</span>]--; <span class="comment">//移除最左边元素的字符，如果是最多次字符，下次继续缩短窗口，如果是其他字符，下次增大窗口</span></span><br><span class="line">            left++; <span class="comment">//左移，恢复窗口合法性，</span></span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        ans = Math.max(ans, right-left); <span class="comment">//因为是可变长的滑动窗口，保存历史中最大窗口长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="1493-删掉一个元素以后全为-1-的最长子数组"><a href="#1493-删掉一个元素以后全为-1-的最长子数组" class="headerlink" title="1493. 删掉一个元素以后全为 1 的最长子数组"></a><a href="https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/">1493. 删掉一个元素以后全为 1 的最长子数组</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>; <span class="comment">//k是维护变量，长度</span></span><br><span class="line">   <span class="keyword">while</span>(right &lt; nums.length)&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums[right] == <span class="number">0</span>) ++k; <span class="comment">//更新维护变量</span></span><br><span class="line">       <span class="keyword">while</span>(k &gt; <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[left] == <span class="number">0</span>) --k;</span><br><span class="line">           left++; <span class="comment">//左移，直至找到更改维护变量的下标</span></span><br><span class="line">       &#125;</span><br><span class="line">       right++;</span><br><span class="line">       ans = Math.max(ans, right- left-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="978-最长湍流子数组"><a href="#978-最长湍流子数组" class="headerlink" title="978. 最长湍流子数组"></a><a href="https://leetcode-cn.com/problems/longest-turbulent-subarray/">978. 最长湍流子数组</a></h2><p>376摆动序列的变形。思路也来自于此</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxTurbulenceSize</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>, cur = <span class="number">0</span>; <span class="comment">//维护变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; len)&#123;</span><br><span class="line">        pre = arr[right] - arr[right-<span class="number">1</span>]; <span class="comment">//小于0，前是山峰，大于0，前是低谷，等于0，为平路</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((cur &gt; <span class="number">0</span> &amp;&amp; pre &gt; <span class="number">0</span>) || (cur &lt; <span class="number">0</span> &amp;&amp; pre &lt; <span class="number">0</span>))&#123; <span class="comment">//不满足条件，左边界右移右指针左边</span></span><br><span class="line">            left = right-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="number">0</span>) left = right; <span class="comment">//不满足条件：左边界右移到右指针</span></span><br><span class="line">        cur = pre; <span class="comment">//更新维护变量</span></span><br><span class="line">        </span><br><span class="line">        ans = Math.max(ans, right - left+<span class="number">1</span>);</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面给出思路相似的三个题</p>
<p>都是在一个字符串s找另一个字符串t相关性，其中438和567是一样的题，只是叫法不一样，而76则是它们的升级版</p>
<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//本题思路很好想，不停的拿p长度的s子串与p对比，难点在于，使用什么样的结构</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pLen</span> <span class="operator">=</span> p.length();</span><br><span class="line">    <span class="keyword">if</span>(sLen &lt; pLen) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="type">int</span>[] sCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];  <span class="comment">//维护的变量：哈希表sCount, pCount不算是维护变量，只是起一个与窗口元素对比的作用</span></span><br><span class="line">    <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; ++i)&#123;</span><br><span class="line">        sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Arrays.equals(sCount, pCount))&#123;</span><br><span class="line">        ans.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sLen - pLen; ++i)&#123;</span><br><span class="line">        sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--; <span class="comment">// 去掉左指针的元素，左指针和右指针是一个指针，共同移动              窗口后移，例如ecbauuuucba ,sCount现在是ecb，去掉e加入cba，这样就对比成功了</span></span><br><span class="line">        sCount[s.charAt(i+pLen) - <span class="string">&#x27;a&#x27;</span>]++; </span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(sCount, pCount))&#123; <span class="comment">//这种双哈希表的做法好处就是节省了两子串比较的成本，直接比较哈希表是否相等即可</span></span><br><span class="line">            ans.add(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h2><p>同上一题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] sC = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] pC = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s1.length(), len2 = s2.length();</span><br><span class="line">    <span class="keyword">if</span>(len1 &gt; len2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len1; ++i)&#123;</span><br><span class="line">        sC[s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        pC[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Arrays.equals(sC, pC)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len2 - len1; ++i)&#123;</span><br><span class="line">        pC[s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        pC[s2.charAt(i+len1) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">if</span>(Arrays.equals(sC, pC)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h2><p>本题是前两题的升级版：也是双哈希表，只是采用了双map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//map元素</span></span><br><span class="line">     	<span class="comment">//维护的变量：窗口，这个窗口会加入两种变量，实变量与虚变量</span></span><br><span class="line">       <span class="comment">//实变量：tMap中含有的元素，虚变量：tMap不含有的元素。</span></span><br><span class="line">    <span class="comment">//这里新增两个概念只是为了让滑动窗口更好理解一点。</span></span><br><span class="line">        Map&lt;Character, Integer&gt; sMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; tMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//起到对比作用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : t.toCharArray())&#123;</span><br><span class="line">            tMap.put(c, tMap.getOrDefault(c, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">match</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length()+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(tMap.containsKey(c))&#123; <span class="comment">//判断tMap中是否含有实变量</span></span><br><span class="line">                sMap.put(c, sMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>); <span class="comment">//更新维护变量：添加实变量</span></span><br><span class="line">                <span class="keyword">if</span>(sMap.get(c).equals(tMap.get(c)))&#123; </span><br><span class="line">                    match++; <span class="comment">//窗口合法性破坏</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(match == tMap.size())&#123; <span class="comment">//表示窗口的元素全部集齐</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; len)&#123; <span class="comment">//寻找下标 这里是找答案</span></span><br><span class="line">                    ans[<span class="number">0</span>] = left;</span><br><span class="line">                    ans[<span class="number">1</span>] = right+<span class="number">1</span>;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span>(sMap.getOrDefault(c1, <span class="number">0</span>) != <span class="number">0</span>)&#123; <span class="comment">//不是虚变量，即移除实变量</span></span><br><span class="line">                    sMap.put(c1, sMap.get(c1)-<span class="number">1</span>); <span class="comment">//移除实变量</span></span><br><span class="line">                    <span class="keyword">if</span>(sMap.get(c1) &lt; tMap.get(c1))&#123;</span><br><span class="line">                        match--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++; <span class="comment">//左移指针，移除虚变量</span></span><br><span class="line">            &#125;</span><br><span class="line">            right++; <span class="comment">//right每一次右移，相当于将虚变量添加入了sMap中</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> s.substring(ans[<span class="number">0</span>], ans[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>双指针：顾名思义在遍历对象的过程中，使用两个指针进行扫描，达成相应目的</p>
<p>常见的双指针两种：快慢指针和左右指针。</p>
<p>快慢指针一般应用于滑动窗口，左右指针一般应用于二分查找。数据结构一般常见于数组、字符串和链表。</p>
<h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><p>同方向遍历，slow指向待处理的位置，fast指向待处理的元素，下面给出三个思路一模一样的简单题</p>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != val)&#123; <span class="comment">//fast指向待处理的元素，判断是不是val，不是，赋值到slow位置上</span></span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[slow] != nums[fast])&#123; <span class="comment">//fast找不相等元素</span></span><br><span class="line">            slow++; <span class="comment">//形成错位</span></span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow+<span class="number">1</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != <span class="number">0</span>)&#123; <span class="comment">//找不是0的元素，然后给slow处理</span></span><br><span class="line">            swap(nums, slow, fast);</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面三个题思路都是相似的，fast负责先走，找到待处理的元素，slow负责待着原地，等着fast找到元素，fast找到后，处理好元素，slow才继续往后走。</p>
<p>下面给出进阶二分查找，但里面的思路和上面是一样的，可能多了其他约束</p>
<h2 id="611-有效三角形的个数"><a href="#611-有效三角形的个数" class="headerlink" title="611. 有效三角形的个数"></a><a href="https://leetcode-cn.com/problems/valid-triangle-number/">611. 有效三角形的个数</a></h2><p>注意下面7-14行，和上面思想是一样的，fast往后走，找到右边界（或者说某个值），然后回来处理，处理结束后，slow++，即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">triangleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//双指针：用i固定住，j,k则是双指针移动，和三数之和类似</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">2</span>; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> i+<span class="number">1</span>; <span class="comment">//将fast放在这，是因为当slow++向后移，fast不可能重新从slow+1开始遍历，因为随着slow增加，前面的数肯定</span></span><br><span class="line">        <span class="comment">//会继续算在ans里，所以，fast继续在老位置向后遍历。或者记住我们是查找范围不是查找值即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> i+<span class="number">1</span>; slow &lt; len - <span class="number">1</span>; ++slow)&#123;</span><br><span class="line">            <span class="keyword">while</span>(fast &lt; len &amp;&amp; nums[fast] &lt; nums[slow] + nums[i])&#123;</span><br><span class="line">                <span class="comment">//等到fast == i + slow时，就不满足条件了</span></span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Math.max(fast - slow-<span class="number">1</span>, <span class="number">0</span>); <span class="comment">//[slow,fast],这个区间的数都表示第三边小于两边之和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="左右指针"><a href="#左右指针" class="headerlink" title="左右指针"></a>左右指针</h1><p>一般的左右指针都是二分查找，详细内容可见二分查找笔记。</p>
<p>下面给出三个不是二分查找的，是左右指针比较，然后进行相应的处理，</p>
<h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left)))&#123; <span class="comment">//去掉除去不是数字或字母的</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right)))&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//化成小写字母再判断</span></span><br><span class="line">        <span class="keyword">if</span>(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新解法：下面增加两个相似的算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="comment">//处理left字符，直至满足题目要求</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="comment">//处理Right字符，直至满足题目要求</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//比较left和左右字符</span></span><br><span class="line">    <span class="comment">//不满足条件返回fasle</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="125-验证回文串-1"><a href="#125-验证回文串-1" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isLetterOrDigit(s.charAt(left)))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isLetterOrDigit(s.charAt(right)))&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare/">844. 比较含退格的字符串</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(), tLen = t.length();</span><br><span class="line">      <span class="type">int</span> <span class="variable">sIndex</span> <span class="operator">=</span> sLen-<span class="number">1</span>, tIndex = tLen-<span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">skipS</span> <span class="operator">=</span> <span class="number">0</span>, skipT = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>(sIndex &gt;= <span class="number">0</span> || tIndex &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">while</span>(sIndex &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(s.charAt(sIndex) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                  skipS++;</span><br><span class="line">                  sIndex--;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipS &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                  skipS--;</span><br><span class="line">                  sIndex--;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span>(tIndex &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(t.charAt(tIndex) == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                  skipT++;</span><br><span class="line">                  tIndex--;</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(skipT &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                  skipT--;</span><br><span class="line">                  tIndex--;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(sIndex &gt;= <span class="number">0</span> &amp;&amp; tIndex &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(s.charAt(sIndex) != t.charAt(tIndex))&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(sIndex &gt;= <span class="number">0</span> || tIndex &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//表示有一个走到底了</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          sIndex--;</span><br><span class="line">          tIndex--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>





<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] + nums[right] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//表示左边绝对值更大</span></span><br><span class="line">            arr[index] = nums[left] * nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr[index] = nums[right] * nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Arrays.sort(nums); <span class="comment">//排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len -<span class="number">2</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> ans; <span class="comment">//当三元组第一个大于0，表示为后面不可能为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//去重,重复的元素不能一直用</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i+<span class="number">1</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//表示left小了</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                list.add(nums[left]);</span><br><span class="line">                list.add(nums[right]);</span><br><span class="line">                ans.add(list);</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++; <span class="comment">//去重</span></span><br><span class="line">                <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>二叉树算法题总结</title>
    <url>/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="二叉树总结"><a href="#二叉树总结" class="headerlink" title="二叉树总结"></a>二叉树总结</h1><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>二叉树的遍历可分为两种，深度优先遍历和广度优先遍历</p>
<p>其中这两种遍历又可发散为三种深度优先遍历和一种广度优先遍历</p>
<ul>
<li>前序遍历：根左右</li>
<li>中序遍历：左根右</li>
<li>后序遍历：左右根</li>
</ul>
<p>和</p>
<ul>
<li>层序遍历</li>
</ul>
<h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a><strong>递归</strong></h2><p>其中深度优先遍历的递归写法最好写，下面给出总的递归遍历，基本都能懂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">         ...; <span class="comment">//根，前序遍历</span></span><br><span class="line">         dfs(root.left); <span class="comment">//左</span></span><br><span class="line">         ...; <span class="comment">//根，中序遍历</span></span><br><span class="line">         dfs(root.right); <span class="comment">//右</span></span><br><span class="line">         ...; <span class="comment">//根，后序遍历</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a><strong>迭代</strong></h2><p>前序遍历迭代，最简单，出栈节点即<strong>访问节点</strong>和<strong>处理节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="comment">//迭代</span></span><br><span class="line">     <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">         List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">         Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">         stack.push(root);</span><br><span class="line">         <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">             <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">             ans.add(node.val);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">             <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>中序</p>
<p>中序遍历，左根右，需要一直左移到null，然后弹出来，处理，然后右子树入栈，再左移右子树第一个。然后依次入栈弹栈接着上面步骤处理，直到结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">         List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">         Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">         <span class="keyword">while</span>(root != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">             <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                 stack.push(root);</span><br><span class="line">                 root = root.left;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 root = stack.pop();</span><br><span class="line">                 ans.add(root.val);</span><br><span class="line">                 root = root.right;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>后序</p>
<p>左右根</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">         List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">         Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">         <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">         <span class="keyword">while</span>(root != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">             <span class="comment">//左子树不为空，入栈</span></span><br><span class="line">             <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                 stack.push(root);</span><br><span class="line">                 root = root.left;</span><br><span class="line">             &#125;</span><br><span class="line">             root = stack.pop();</span><br><span class="line">             <span class="keyword">if</span>(root.right == <span class="literal">null</span> || root.right == node)&#123; <span class="comment">//如果右子树也为空，表叶子节点，则访问，或者曾经访问过该节点</span></span><br><span class="line">                 ans.add(root.val);</span><br><span class="line">                 node = root;</span><br><span class="line">                 root = <span class="literal">null</span>;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 stack.push(root);</span><br><span class="line">                 root = root.right;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可得三种遍历顺序各不相同，很麻烦。</p>
<h2 id="统一迭代"><a href="#统一迭代" class="headerlink" title="统一迭代"></a><strong>统一迭代</strong></h2><p>下面给出一种三种遍历的统一迭代写法</p>
<p>也是一种递归的思想，采取了栈实现。</p>
<p>栈的特性是先进后出，所以遍历顺序与入栈顺序相反。例如，前序是，根左右，那么入栈就是右左根。</p>
<p>这是一种统一标记法，思想是<strong>每个节点会入栈两次</strong>，节点A第一次入栈是因为与其他节点有附属关系，被动入栈，第二次入栈会将节点A做上null标记，然后重新调整节点的入栈顺序。比如，当前栈顶元素不是null标记，假设是前序遍历，那么会弹出这个节点，然后先将该节点的右子树入栈，再将该节点左子树入栈，最后将该节点入栈并做上Null标记，这就是它的第二次入栈，是为了调整它子树的入栈顺序。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">         Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">         List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">         stack.push(root); <span class="comment">//第一次入栈</span></span><br><span class="line">         <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">             <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek(); <span class="comment">//判断当前节点是否为空</span></span><br><span class="line">             <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                 node = stack.pop(); <span class="comment">//出栈</span></span><br><span class="line"> </span><br><span class="line">                 <span class="comment">//根据栈特性，先进后出，前序遍历顺序前左右，可以得知入栈顺序，右左前</span></span><br><span class="line"><span class="comment">// **后序**</span></span><br><span class="line">                 stack.push(node); <span class="comment">//入栈，第二次入栈</span></span><br><span class="line">                 stack.push(<span class="literal">null</span>); <span class="comment">//标记</span></span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line"></span><br><span class="line"><span class="comment">// **中序**</span></span><br><span class="line">                 stack.push(node); <span class="comment">//入栈，第二次入栈</span></span><br><span class="line">                 stack.push(<span class="literal">null</span>); <span class="comment">//标记</span></span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);</span><br><span class="line">								 </span><br><span class="line"><span class="comment">//**前序**</span></span><br><span class="line">                 stack.push(node); <span class="comment">//入栈，第二次入栈</span></span><br><span class="line">                 stack.push(<span class="literal">null</span>); <span class="comment">//标记</span></span><br><span class="line"> </span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 stack.pop(); <span class="comment">//弹出null</span></span><br><span class="line">                 node = stack.pop();</span><br><span class="line">                 ans.add(node.val);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h1><p>根据队先进先出的顺序，层序遍历用队列从左到右的入队，然后处理每个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">         List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">         Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">//队列</span></span><br><span class="line">         que.offer(root); <span class="comment">//入队</span></span><br><span class="line">         <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size(); <span class="comment">//这里要注意，要将size提出来，因为随着队列不断入队出队，队列的长度时变化的，用size固定</span></span><br><span class="line">             List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">                 <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                 ans.add(node.val); <span class="comment">//处理节点，即访问节点</span></span><br><span class="line">                 <span class="keyword">if</span>(node.left != <span class="literal">null</span>) que.offer(node.left);</span><br><span class="line">                 <span class="keyword">if</span>(node.right != <span class="literal">null</span>) que.offer(node.right);</span><br><span class="line">             &#125;</span><br><span class="line">             list.add(ans);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> list;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>层序遍历问题，基本上掌握了上面的代码，lc上的层序遍历题就没大问题。</p>
<ul>
<li><strong><strong><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></strong></strong></li>
<li><strong><strong><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></strong></strong></li>
<li><strong><strong><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></strong></strong></li>
<li><strong><strong><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></strong></strong></li>
<li><strong><strong><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></strong></strong></li>
<li><strong><strong><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></strong></strong></li>
<li><strong><strong><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></strong></strong></li>
<li><strong><strong><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></strong></strong></li>
<li><strong><strong><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></strong></strong></li>
<li><strong><strong><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></strong></strong></li>
<li><strong><strong><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></strong></strong></li>
</ul>
<p>****<a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a>这个题挺巧妙的，可以做一下**</p>
<p>/</p>
<p>上面都是层序遍历的模板题，基本上没有变化。可能根据题意在不同的地方做出不同的处理就完成。</p>
<p>下面给出一些深度优先遍历的leetcode题</p>
<h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><strong><strong><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></strong></strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">				<span class="comment">//处理的单层逻辑</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = node;</span><br><span class="line">			</span><br><span class="line">				<span class="comment">//左右递归</span></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><strong><strong><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></strong></strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isTrue(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归函数：返回值-boolean 保证下面的为正确，参数为root.left 和 root.right</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTrue</span><span class="params">(TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> || right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//剩下的当前值相同，比较下面的结构是否相同</span></span><br><span class="line">        <span class="keyword">return</span> isTrue(left.left,right.right) &amp;&amp; isTrue(left.right,right.left); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><strong><strong><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></strong></strong></h2><p>自上而下~前序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//单层处理逻辑</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> deep(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> deep(root.right);</span><br><span class="line">        <span class="keyword">if</span>(l - r &gt; <span class="number">1</span> || l - r &lt; -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//左右遍历</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">l1</span> <span class="operator">=</span> isBalanced(root.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r1</span> <span class="operator">=</span> isBalanced(root.right);</span><br><span class="line">	      </span><br><span class="line">        <span class="keyword">return</span> l1 &amp;&amp; r1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deep</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(deep(root.left), deep(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><strong><strong><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></strong></strong></h2><p>前序遍历，主要是根据完全二叉树的特性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//迭代用层序遍历很好求</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">            left = left.left;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right != <span class="literal">null</span>)&#123;</span><br><span class="line">            right = right.right;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; l) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><strong><strong><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></strong></strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">				</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				<span class="comment">//单层处理逻辑</span></span><br><span class="line">				<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> p.val == q.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="572-另一棵树的子树"><a href="#572-另一棵树的子树" class="headerlink" title="572. 另一棵树的子树"></a><strong><strong><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></strong></strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="comment">//首先创建一个判断是否相同的子树的函数，然后不断的用root的左右子树不断和subRoot比较，找到一个true既可</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(subRoot == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				<span class="comment">//**isSame函数就是单层处理逻辑，判断两个树是否相同，然后左右递归**</span></span><br><span class="line">        <span class="keyword">return</span> isSame(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSame</span><span class="params">(TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; isSame(p.left, q.left) &amp;&amp; isSame(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><strong><strong><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></strong></strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">				<span class="comment">//前序遍历的单层逻辑</span></span><br><span class="line">        root1.val = root1.val + root2.val;</span><br><span class="line"></span><br><span class="line">        root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="993-二叉树的堂兄弟节点"><a href="#993-二叉树的堂兄弟节点" class="headerlink" title="993. 二叉树的堂兄弟节点"></a><strong><strong><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></strong></strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode xParent, yParent;</span><br><span class="line">    <span class="type">int</span> xDeep, yDeep;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCousins</span><span class="params">(TreeNode root, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        dfs(<span class="literal">null</span>, root, <span class="number">1</span>);</span><br><span class="line">        <span class="type">return</span> <span class="variable">xDeep</span> <span class="operator">=</span>= yDeep &amp;&amp; xParent != yParent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode parent, TreeNode root, <span class="type">int</span> deep)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val == x)&#123;</span><br><span class="line">            xDeep = deep;</span><br><span class="line">            xParent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val == y)&#123;</span><br><span class="line">            yDeep =  deep;</span><br><span class="line">            yParent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root, root.left, deep+<span class="number">1</span>);</span><br><span class="line">        dfs(root, root.right, deep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><strong><strong><a href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></strong></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        backtracking(root, <span class="string">&quot;&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(TreeNode root, String str, List&lt;String&gt; ans)</span>&#123;</span><br><span class="line">         <span class="comment">//说明该节点为叶子节点,满足终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            str += root.val;</span><br><span class="line">            ans.add(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            backtracking(root.left, str + root.val + <span class="string">&quot;-&gt;&quot;</span>, ans); <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            backtracking(root.right, str + root.val + <span class="string">&quot;-&gt;&quot;</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><strong><strong><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></strong></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        find(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> deep)</span>&#123;</span><br><span class="line">        <span class="comment">//当前节点为叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; deep)&#123;</span><br><span class="line">                max = deep;</span><br><span class="line">                ans = root.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            find(root.left, deep+<span class="number">1</span>); <span class="comment">//回溯体现在deep+1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            find(root.right, deep+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><strong><strong><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></strong></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        dfs(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum == root.val)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(root.left, sum - root.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">           dfs(root.right, sum - root.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><strong><strong><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></strong></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        backtracking(root, targetSum, ans, list);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(TreeNode root, <span class="type">int</span> sum, List&lt;List&lt;Integer&gt;&gt; ans,</span></span><br><span class="line"><span class="params">    List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum == root.val)&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            backtracking(root.left, sum - root.val, ans, list);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            backtracking(root.right, sum - root.val, ans, list);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><strong><strong><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></strong></strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//叶子节点了，为0</span></span><br><span class="line">        <span class="comment">//查询作业子树的深度</span></span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">				<span class="comment">//单层处理逻辑</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><strong><strong><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></strong></strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//左叶子</span></span><br><span class="line">                sum = root.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right) + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><strong><strong><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></strong></strong></h2><p>需要限制条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span> &amp;&amp; root.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.right), minDepth(root.left)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="110-平衡二叉树-1"><a href="#110-平衡二叉树-1" class="headerlink" title="110. 平衡二叉树"></a><strong><strong><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></strong></strong></h2><p>自下而上~后序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> height(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//高度：该节点到叶子节点的最长简单路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> height(root.left); <span class="comment">//拿到子树的高度</span></span><br><span class="line">        <span class="keyword">if</span>(leftHeight == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> height(root.right); </span><br><span class="line">        <span class="keyword">if</span>(rightHeight == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="构造二叉树模板"><a href="#构造二叉树模板" class="headerlink" title="构造二叉树模板"></a>构造二叉树模板</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line">构造函数</span><br><span class="line">因为一般都是数组构造二叉树，所以left和right的二叉树的范围，因为我定义其他的东西都是全局变量，所以形参只有两个比较方便。</span><br><span class="line">TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span>; <span class="comment">//不满足范围，表示构造不了二叉树</span></span><br><span class="line"></span><br><span class="line">	index...确定当前的节点的下标</span><br><span class="line">	</span><br><span class="line">	value...根据下标找到数组中的值，然后构造树节点</span><br><span class="line"></span><br><span class="line">	<span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//root节点的左右顺序需要根据题目来确定</span></span><br><span class="line">	root.left = dfs(left, index-<span class="number">1</span>);</span><br><span class="line">	root.right = dfs(index+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><strong><strong><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></strong></strong></h2><p>主要是明白中序和后序构造二叉树的原理，后序数组从后遍历，每次都是中序数组当前的根节点。</p>
<p>怎么从知道中序数组根节点的值，到值的下标，采用哈希来记录，这样就可以根据后序数组最后一个值，知道中序根节点的下标来，分割数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] inorder;</span><br><span class="line">    <span class="type">int</span>[] postorder;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inorder = inorder;</span><br><span class="line">        <span class="built_in">this</span>.postorder = postorder;</span><br><span class="line">        <span class="built_in">this</span>.len = postorder.length-<span class="number">1</span>; <span class="comment">//后序数组的最后一个，即中序数组当前的根节点</span></span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; ++i)&#123;</span><br><span class="line">            map.put(inorder[i], i); <span class="comment">//map存放中序数组的值及下标</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//先拿到后序节点的值，再去匹配中序数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> postorder[len]; <span class="comment">//中序数组的当前根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(val); <span class="comment">//中序数组的根节点下标</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val); <span class="comment">//根节点</span></span><br><span class="line">        len--; <span class="comment">//换新根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//先右后左，是根据后序遍历数组的根节点分布来的</span></span><br><span class="line">        root.right = dfs(index+<span class="number">1</span>, right);</span><br><span class="line">        root.left = dfs(left, index-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"><strong>105. 从前序与中序遍历序列构造二叉树</strong></a></p>
<h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><strong><strong><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></strong></strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">return</span> backtracking(<span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> left , <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &lt; nums[i])&#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[index]);</span><br><span class="line"></span><br><span class="line">        root.left = backtracking(left, index-<span class="number">1</span>);</span><br><span class="line">        root.right = backtracking(index+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><strong><strong><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></strong></strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line"></span><br><span class="line">        root.left = build(left, mid-<span class="number">1</span>);</span><br><span class="line">        root.right = build(mid+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p><strong>性质1</strong>：</p>
<ol>
<li>若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。</li>
<li>若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。</li>
<li>任意结点的左、右子树也分别为二叉搜索树。</li>
</ol>
<p><strong>性质2:</strong></p>
<p>中序遍历二叉搜索树具有有序性。</p>
<h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><strong><strong><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></strong></strong></h2><p>根据二叉搜索树的特性，我们在递归这棵树树，有了<strong>方向性</strong>，根节点总是大于左边，小于右边。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val) <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val) <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><strong><strong><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></strong></strong></h2><p>性质1：前序遍历，不断的向下判断当前的root是否满足范围，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">long</span> low,<span class="type">long</span> high)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= low || root.val &gt;= high) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, low, root.val) &amp;&amp; dfs(root.right, root.val, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>性质2：中序遍历，采用pre记住上一个节点是关键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        inorder(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= root.val)&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>中序遍历二叉搜索树具有有序性，依此性质可以消灭很多类似的题</p>
<p>模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//全局变量，用于记住上一个节点</span></span><br><span class="line">.... <span class="comment">//满足某些特定题目规则所作的变量</span></span><br><span class="line"></span><br><span class="line">... main()&#123;&#125; <span class="comment">//主函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		inorder(root.left);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(pre != <span class="literal">null</span>)&#123; <span class="comment">//表示不是中序遍历最后一个节点</span></span><br><span class="line">		</span><br><span class="line">		... <span class="comment">//完成某种规则所需的操作</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pre = root; <span class="comment">//记住上一个节点		</span></span><br><span class="line"></span><br><span class="line">		inorder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><strong><strong><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></strong></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; ans &gt; root.val - pre.val) ans = root.val - pre.val;</span><br><span class="line">        pre = root;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><strong><strong><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></strong></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); ++i)&#123;</span><br><span class="line">            ans[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        inorder(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.val == root.val)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count == max)&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count &gt; max)&#123;</span><br><span class="line">            list.clear(); <span class="comment">//清除集合</span></span><br><span class="line">            list.add(root.val);</span><br><span class="line">            max = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = root; <span class="comment">//记住上一个节点</span></span><br><span class="line"></span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><strong><strong><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></strong></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//中序遍历有序，累加从后累加，那改成逆中序遍历即可</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        inorder(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        inorder(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>)&#123;</span><br><span class="line">            root.val += pre.val;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        inorder(root.left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入删除"><a href="#插入删除" class="headerlink" title="插入删除"></a>插入删除</h2><p>主要考察二叉搜索树的性质</p>
<h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><strong><strong><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></strong></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val) root.left = insertIntoBST(root.left, val);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val) root.right = insertIntoBST(root.right, val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><strong><strong><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></strong></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">            <span class="comment">//找到删除节点了</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//叶子节点，直接删除</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//左边为空</span></span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//右边为空</span></span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    node = node.left;</span><br><span class="line">                &#125;</span><br><span class="line">                node.left = root.left; <span class="comment">//这不是指针，只是node.left指向root.left</span></span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">                root.left = deleteNode(root.left, key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(root.val &lt; key)&#123;</span><br><span class="line">                root.right = deleteNode(root.right, key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><strong><strong><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></strong></strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前节点小于low，那么说明这个节点及左子树修剪，继续修建右边</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low) <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line">        <span class="comment">//当前节点大于high，那么说明这个节点及右子树修剪，继续修建左边</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high) <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合格</span></span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>ASCII码</title>
    <url>/%E7%AE%97%E6%B3%95%E9%A2%98%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%93%88%E5%B8%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>当遇见字符串算法题，需要用哈希来做的话，定义各种哈希的情况</p>
<p>如果是小写字母或大写字母，长度为26</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">hash[C - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">hash[C - <span class="string">&#x27;A&#x27;</span>]++;</span><br></pre></td></tr></table></figure>

<p>如果有空格、字母、特殊字符，长度128</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">hash[C - <span class="string">&#x27; &#x27;</span>]++;<span class="comment">//从空格开始，因为ASCII码从空格开始，共128个</span></span><br><span class="line">hash[C - <span class="string">&#x27; &#x27;</span>]++;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
