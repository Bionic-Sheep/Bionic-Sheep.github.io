{"meta":{"title":"Sheep","subtitle":"莫问前程，但行好事","description":"记录一下","author":"Bionic-Sheep","url":"http://Bionic-Sheep.github.io","root":"/"},"pages":[{"title":"about","date":"2022-04-03T02:14:21.000Z","updated":"2022-04-03T02:14:50.811Z","comments":true,"path":"about/index.html","permalink":"http://bionic-sheep.github.io/about/index.html","excerpt":"","text":"自我介绍：研二在读"},{"title":"diy","date":"2022-04-03T10:10:34.000Z","updated":"2022-04-03T10:10:34.430Z","comments":true,"path":"diy/index.html","permalink":"http://bionic-sheep.github.io/diy/index.html","excerpt":"","text":""}],"posts":[{"title":"2022.4.2 京东笔试","slug":"4.2京东笔试","date":"2022-04-02T13:42:37.889Z","updated":"2022-04-03T10:33:32.602Z","comments":true,"path":"4.2京东笔试/","link":"","permalink":"http://bionic-sheep.github.io/4.2%E4%BA%AC%E4%B8%9C%E7%AC%94%E8%AF%95/","excerpt":"","text":"第一题： 在满二叉树上行走，U上L左R右 12345678910111213141516171819202122232425262728293031323334353637383940/输入描述//第一行两个空格隔开的正整数N，X////接下来一行一个长度为N的只包含U,L,R三种字母的字符串。////对于90%的数据，1≤N≤100，1≤X＜210////对于100%的数据，1≤N≤5.105，1≤X＜230class Main&#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String str; long n; //路径 long x;//所在节点编号 while (in.hasNext()) &#123; n = in.nextInt(); x = in.nextInt(); str = in.next(); for (int i = 0; i &lt; n; ++i) &#123; char c = str.charAt(i); //拿到当前行走命令 //左孩子是 2*x 右孩子是 2*x+1 if (c == &#x27;U&#x27; || c ==&#x27;u&#x27;) &#123; x = (long)x / 2; &#125; else if (c == &#x27;R&#x27; || c == &#x27;r&#x27;) &#123; //向右走 x = (long)(2 * x + 1); &#125; else &#123; x = (long)(2 * x); &#125; &#125; System.out.println(x); &#125; &#125;&#125; 本题只过了0.91，难点就在于避免超时，一开始x的接受没有用long，只能过55，后面仔细阅读题目才发现，数据范围很大，改为long，但还是有一例数据难过，可能是字符串导致的超时。 第二题 粉刷匠：不是很理解题意，但是最多的次数为3，我判断失误，只过了0.09，但是可以先判断是否相等，相等为0,不等输出rand()mod3+1，可以得到0.81，大失误。","categories":[],"tags":[]},{"title":"2022.4.2 360笔试","slug":"4.2360笔试","date":"2022-04-02T13:35:20.845Z","updated":"2022-04-02T13:56:35.185Z","comments":true,"path":"4.2360笔试/","link":"","permalink":"http://bionic-sheep.github.io/4.2360%E7%AC%94%E8%AF%95/","excerpt":"","text":"第一题： 12345678910111213141516171819202122232425262728293031323334353637383940//判断字符串串是否对称import java.util.*;public class Main &#123; public static void main(String[] args) &#123;*/ Scanner in = new Scanner(System.in); char[] ch = &#123;&#x27;A&#x27;, &#x27;H&#x27;, &#x27;I&#x27;,&#x27;M&#x27;,&#x27;N&#x27;,&#x27;O&#x27;,&#x27;T&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;W&#x27;,&#x27;X&#x27;,&#x27;Y&#x27;&#125;; String str = &quot;&quot;; while(in.hasNext())&#123; str = in.nextLine(); int k = -1; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(char c : ch)&#123; map.put(c,1); &#125; for(char c : str.toCharArray())&#123; if(!map.containsKey(c))&#123; k = 1; break; &#125; &#125; if(k == -1)&#123; int left = 0, right= str.length()-1; while(left &lt;= right)&#123; if(str.charAt(left) != str.charAt(right))&#123; k = 1; break; &#125; left++; right--; &#125; &#125; if(k == 1) System.out.println(&quot;NO&quot;); else System.out.println(&quot;YES&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//吃鸡组队class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int t; t = in.nextInt(); while(in.hasNext())&#123; int a, b, c, d; a = in.nextInt(); b = in.nextInt(); c = in.nextInt(); d = in.nextInt(); int ans = 0; //首先将四人队补充完整 ans += d; if (a &gt;= c) &#123; //单人队的数量超过三人队，可全部扩充为四人队 ans += c; a -= c; c = 0; &#125; else &#123; ans += a; // a = 0; &#125; ans += b / 2; if (b % 2 == 0) &#123; //两人队也没了 b = 0; &#125; else &#123; b = 1; &#125; //现在的情况是d == 0, c != 0 则a == 0, c == 0,说明a还剩 //如果a很多的情况，可能存在浪费 if (c == 0) &#123; if (b == 1) &#123; if (a &gt;= 2) &#123; ans += 1; a -= 2; &#125; &#125; &#125; ans += a/4; System.out.println(ans); &#125; &#125;&#125;*/ 情况：两道题都挺简单的，都AC了，第一种反转字符串，只要排除掉非对称字符即可，第二题和leetcode上面找零钱非常类似，核心就是5美元的数量，对应到本题就是单人队的数量，以单人队来补充bc队的人数。 代码可读性很差， 因为在时间紧张的条件下，不会在意代码的优美。","categories":[],"tags":[]},{"title":"ASCII码","slug":"算法题中设置哈希数组","date":"2022-03-27T07:42:51.397Z","updated":"2022-03-30T02:11:17.049Z","comments":true,"path":"算法题中设置哈希数组/","link":"","permalink":"http://bionic-sheep.github.io/%E7%AE%97%E6%B3%95%E9%A2%98%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%93%88%E5%B8%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"当遇见字符串算法题，需要用哈希来做的话，定义各种哈希的情况 如果是小写字母或大写字母，长度为26 123int[] hash = new int[26];hash[C - &#x27;a&#x27;]++;hash[C - &#x27;A&#x27;]++; 如果有空格、字母、特殊字符，长度128 123int[] hash = new int[128];hash[C - &#x27; &#x27;]++;//从空格开始，因为ASCII码从空格开始，共128个hash[C - &#x27; &#x27;]++;","categories":[],"tags":[]},{"title":"Java中的Integer的长度判断","slug":"Java中的Integer的长度判断","date":"2022-03-26T12:55:19.944Z","updated":"2022-03-30T02:10:29.659Z","comments":true,"path":"Java中的Integer的长度判断/","link":"","permalink":"http://bionic-sheep.github.io/Java%E4%B8%AD%E7%9A%84Integer%E7%9A%84%E9%95%BF%E5%BA%A6%E5%88%A4%E6%96%AD/","excerpt":"","text":"Java中的Integer的长度判断Java的数据类型是两种： 基本数据类型:int, double…..等 引用类型：Integer，Double等 一般比较大小有两种，要么==，要么equals。 ==在比较基本数据类型时，是数值大小，比较引用类型时，是比较两个引用对象是否相等。 只有equals，不管是基本数据类型还是引用数据累心，都比较的是数值大小（或者重写equals方法的内容），所以我们在比较引用类型对象的数值大小时，尽量采用equals。 下面给个例子 123456789int a = 127, b = 127;System.out.println(a == b);// trueInteger c = 127, d = 127;System.out.println(a == b); //trueint a = 128, b = 128;System.out.println(a == b);// trueInteger c = 128, d = 128; System.out.println(a == b); //false 出现上面情况是因为Integer将[-128,127]范围的整数都提前实例化了，只要数值相等，==比较的都是同一个对象。我们可以用Integer.intValue转为基本数据类型，或者equals来比较","categories":[],"tags":[]},{"title":"滑动窗口","slug":"滑动窗口","date":"2022-03-26T04:56:05.674Z","updated":"2022-03-30T02:09:37.932Z","comments":true,"path":"滑动窗口/","link":"","permalink":"http://bionic-sheep.github.io/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"滑动窗口不断的调节子序列的起始位置和终止位置，得到我们想要的结果。 一般的模板： 12345for(枚举选择) 右边界 while(窗口条件) 左边界 更新结果 下面给出一种更常用的模板 1234567891011121314151617181920212223242526272829//1.需要维护的变量，长度大小，数和，哈希表等int sum, Map。。。//2.定义首尾端int left = 0, right = 0while(right &lt; len)&#123;//3.更新维护的变量sum +=, map.put.. //4.下面有两种情况，一种是长度可变的窗口，一种是长度固定的窗口//4.1长度可变，一般是在3更新维护变量时，破坏了窗口的合法性，//需要在while中，更改维护的变量并且左移指针来恢复窗口的合法性while(长度可变)&#123; sum -= nums[left]; left++;&#125;//4.2长度不可变，一般是在满足条件后，用if判断当前窗口是否达到限定长度，//然后左指针迁移一个单位，保证下次右指针右移，窗口长度不变if(长度不变)&#123; left++;&#125;//5.更新答案，一般求法都是求解窗口的最大长度，不是必要步骤，但很常见ans = Math.max(ans, right - left);right++;&#125;//返回答案 209. 长度最小的子数组123456789101112131415161718192021public int minSubArrayLen(int target, int[] nums) &#123; //滑动窗口：右边界走，满足条件在while里处理左边界 int tmp = 0; // step1:定义需要维护的变量，tmp，变量和 int left = 0, right = 0; //step2:窗口的首尾两端 int len = nums.length; int ans = len+1; while(right &lt; len)&#123; tmp += nums[right]; //step3:更新维护的变量 //step4情况1：窗口长度固定：用if语句判断当前窗口是否达到了限定长度， // 达到了，窗口左指针前移一个单位，来保证下一次右指针右移时，窗口长度不变， while(tmp &gt;= target)&#123; //step4情况2：窗口长度可变：当前窗口不合法，tmp和大于目标值， // 用while不断的移动左指针剔除非法元素直至窗口合法，在左指针移动前更新维护的变量 ans = Math.min(right - left, ans); //因为这是求最小，left = 0, right = 0,那么最小的就是0，所以放在while里面合适 tmp -= nums[left]; left++; &#125; &#125; return ans; &#125; 904. 水果成篮12345678910111213141516public int totalFruit(int[] fruits) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); //维护的变量，维护摘下的水果不超过2个 int left = 0, right = 0; int ans = 0; while(right &lt; fruits.length)&#123; map.put(fruits[right], map.getOrDefault(fruits[right], 0) + 1); //更新维护变量：放入水果 while(map.size() &gt; 2)&#123; //判断是否超过窗口条件，长度不固定，这里的窗口长度是两种水果相连的长度，不是两种水果是窗口，所以是可变的 map.put(fruits[left], map.get(fruits[left])-1); //更新维护变量 if(map.get(fruits[left]) == 0) map.remove(fruits[left]); left++; //左指针左移，然后不断的更新维护变量，来破坏窗口的非法性 &#125; ans = Math.max(right - left + 1, ans); //更新答案 right++; &#125; return ans;&#125; 3. 无重复字符的最长子串123456789101112131415161718public int lengthOfLongestSubstring(String s) &#123; //用一个map装字符，当在遍历过程中， //发现map中有这个字符，表示重复了，将左指针定位到该字符的位置，每次遍历的过程比较ans大小 Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); //更新维护变量 int left = 0, right = 0; //首尾 int len = s.length(); int ans = 0; while(right &lt; len)&#123; char c = s.charAt(right); if(map.containsKey(c))&#123; //长度固定:重复子串的长度固定 left = Math.max(map.get(c), left); //这里用Math.max是因为可能出现在left前的位置出现重复字符，但是left不能往左移， &#125; map.put(c, right+1); //更新维护变量 ans = Math.max(ans, right-left+1); right++; &#125; return ans;&#125; 424. 替换后的最长重复字符1234567891011121314151617181920public int characterReplacement(String s, int k) &#123; //难点在于：窗口条件是什么！ 总字符数 - 最多次字符数 &lt;= k 为合法 int[] arr = new int[26]; int left = 0, right = 0; int max = 0; int ans = 0; while(right &lt; s.length())&#123; char c = s.charAt(right); //找最多的字符数的 arr[c - &#x27;A&#x27;]++; // 找维持窗口条件的最多次字符数 max = Math.max(max, arr[c - &#x27;A&#x27;]); while(right - left + 1 - max &gt; k)&#123; //长度可变 arr[s.charAt(left) - &#x27;A&#x27;]--; //移除最左边元素的字符，如果是最多次字符，下次继续缩短窗口，如果是其他字符，下次增大窗口 left++; //左移，恢复窗口合法性， &#125; right++; ans = Math.max(ans, right-left); //因为是可变长的滑动窗口，保存历史中最大窗口长度 &#125; return ans;&#125; 1493. 删掉一个元素以后全为 1 的最长子数组1234567891011121314public int longestSubarray(int[] nums) &#123; int left = 0, right = 0; int k = 0, ans = 0; //k是维护变量，长度 while(right &lt; nums.length)&#123; if(nums[right] == 0) ++k; //更新维护变量 while(k &gt; 1)&#123; if(nums[left] == 0) --k; left++; //左移，直至找到更改维护变量的下标 &#125; right++; ans = Math.max(ans, right- left-1); &#125; return ans;&#125; 978. 最长湍流子数组376摆动序列的变形。思路也来自于此 1234567891011121314151617181920public int maxTurbulenceSize(int[] arr) &#123; int pre = 0, cur = 0; //维护变量 int left = 0, right = 1; int len = arr.length; if(len &lt; 2) return len; int ans = 1; while(right &lt; len)&#123; pre = arr[right] - arr[right-1]; //小于0，前是山峰，大于0，前是低谷，等于0，为平路 if((cur &gt; 0 &amp;&amp; pre &gt; 0) || (cur &lt; 0 &amp;&amp; pre &lt; 0))&#123; //不满足条件，左边界右移右指针左边 left = right-1; &#125; if(pre == 0) left = right; //不满足条件：左边界右移到右指针 cur = pre; //更新维护变量 ans = Math.max(ans, right - left+1); right++; &#125; return ans;&#125; 下面给出思路相似的三个题 都是在一个字符串s找另一个字符串t相关性，其中438和567是一样的题，只是叫法不一样，而76则是它们的升级版 438. 找到字符串中所有字母异位词1234567891011121314151617181920212223242526public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); //本题思路很好想，不停的拿p长度的s子串与p对比，难点在于，使用什么样的结构 int sLen = s.length(); int pLen = p.length(); if(sLen &lt; pLen) return ans; int[] sCount = new int[26]; //维护的变量：哈希表sCount, pCount不算是维护变量，只是起一个与窗口元素对比的作用 int[] pCount = new int[26]; for(int i = 0; i &lt; pLen; ++i)&#123; sCount[s.charAt(i) - &#x27;a&#x27;]++; pCount[p.charAt(i) - &#x27;a&#x27;]++; &#125; if(Arrays.equals(sCount, pCount))&#123; ans.add(0); &#125; for(int i = 0; i &lt; sLen - pLen; ++i)&#123; sCount[s.charAt(i) - &#x27;a&#x27;]--; // 去掉左指针的元素，左指针和右指针是一个指针，共同移动 窗口后移，例如ecbauuuucba ,sCount现在是ecb，去掉e加入cba，这样就对比成功了 sCount[s.charAt(i+pLen) - &#x27;a&#x27;]++; if(Arrays.equals(sCount, pCount))&#123; //这种双哈希表的做法好处就是节省了两子串比较的成本，直接比较哈希表是否相等即可 ans.add(i+1); &#125; &#125; return ans;&#125; 567. 字符串的排列同上一题 123456789101112131415161718public boolean checkInclusion(String s1, String s2) &#123; int[] sC = new int[26]; int[] pC = new int[26]; int len1 = s1.length(), len2 = s2.length(); if(len1 &gt; len2) return false; for(int i = 0; i &lt; len1; ++i)&#123; sC[s1.charAt(i) - &#x27;a&#x27;]++; pC[s2.charAt(i) - &#x27;a&#x27;]++; &#125; if(Arrays.equals(sC, pC)) return true; for(int i = 0; i &lt; len2 - len1; ++i)&#123; pC[s2.charAt(i) - &#x27;a&#x27;]--; pC[s2.charAt(i+len1) - &#x27;a&#x27;]++; if(Arrays.equals(sC, pC)) return true; &#125; return false;&#125; 76. 最小覆盖子串本题是前两题的升级版：也是双哈希表，只是采用了双map 12345678910111213141516171819202122232425262728293031323334353637383940414243//public String minWindow(String s, String t) &#123; //map元素 //维护的变量：窗口，这个窗口会加入两种变量，实变量与虚变量 //实变量：tMap中含有的元素，虚变量：tMap不含有的元素。 //这里新增两个概念只是为了让滑动窗口更好理解一点。 Map&lt;Character, Integer&gt; sMap = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; tMap = new HashMap&lt;&gt;(); //起到对比作用 for(char c : t.toCharArray())&#123; tMap.put(c, tMap.getOrDefault(c, 0)+1); &#125; int left = 0, right = 0; int match = 0; int len = s.length()+1; int[] ans = new int[2]; while(right &lt; s.length())&#123; char c = s.charAt(right); if(tMap.containsKey(c))&#123; //判断tMap中是否含有实变量 sMap.put(c, sMap.getOrDefault(c, 0) + 1); //更新维护变量：添加实变量 if(sMap.get(c).equals(tMap.get(c)))&#123; match++; //窗口合法性破坏 &#125; &#125; while(match == tMap.size())&#123; //表示窗口的元素全部集齐 if(right - left &lt; len)&#123; //寻找下标 这里是找答案 ans[0] = left; ans[1] = right+1; len = right - left; &#125; char c1 = s.charAt(left); if(sMap.getOrDefault(c1, 0) != 0)&#123; //不是虚变量，即移除实变量 sMap.put(c1, sMap.get(c1)-1); //移除实变量 if(sMap.get(c1) &lt; tMap.get(c1))&#123; match--; &#125; &#125; left++; //左移指针，移除虚变量 &#125; right++; //right每一次右移，相当于将虚变量添加入了sMap中 &#125; return s.substring(ans[0], ans[1]); &#125;","categories":[],"tags":[]},{"title":"双指针","slug":"双指针","date":"2022-03-25T13:44:19.947Z","updated":"2022-03-30T02:11:32.863Z","comments":true,"path":"双指针/","link":"","permalink":"http://bionic-sheep.github.io/%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"双指针：顾名思义在遍历对象的过程中，使用两个指针进行扫描，达成相应目的 常见的双指针两种：快慢指针和左右指针。 快慢指针一般应用于滑动窗口，左右指针一般应用于二分查找。数据结构一般常见于数组、字符串和链表。 快慢指针同方向遍历，slow指向待处理的位置，fast指向待处理的元素，下面给出三个思路一模一样的简单题 27. 移除元素123456789101112public int removeElement(int[] nums, int val) &#123; int len = nums.length; int slow = 0, fast = 0; while(fast &lt; nums.length)&#123; if(nums[fast] != val)&#123; //fast指向待处理的元素，判断是不是val，不是，赋值到slow位置上 nums[slow] = nums[fast]; slow++; &#125; fast++; &#125; return slow;&#125; 26. 删除有序数组中的重复项1234567891011public int removeDuplicates(int[] nums) &#123; int slow = 0, fast = 0; while(fast &lt; nums.length)&#123; if(nums[slow] != nums[fast])&#123; //fast找不相等元素 slow++; //形成错位 nums[slow] = nums[fast]; &#125; fast++; &#125; return slow+1; &#125; 283. 移动零123456789101112131415public void moveZeroes(int[] nums) &#123; int slow = 0, fast = 0; while(fast &lt; nums.length)&#123; if(nums[fast] != 0)&#123; //找不是0的元素，然后给slow处理 swap(nums, slow, fast); slow++; &#125; fast++; &#125;&#125;public void swap(int[] nums, int i, int j)&#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;&#125; 上面三个题思路都是相似的，fast负责先走，找到待处理的元素，slow负责待着原地，等着fast找到元素，fast找到后，处理好元素，slow才继续往后走。 下面给出进阶二分查找，但里面的思路和上面是一样的，可能多了其他约束 611. 有效三角形的个数注意下面7-14行，和上面思想是一样的，fast往后走，找到右边界（或者说某个值），然后回来处理，处理结束后，slow++，即 123456789101112131415161718public int triangleNumber(int[] nums) &#123; //双指针：用i固定住，j,k则是双指针移动，和三数之和类似 int len = nums.length; int ans = 0; Arrays.sort(nums); for(int i = 0; i &lt; len - 2; ++i)&#123; int fast = i+1; //将fast放在这，是因为当slow++向后移，fast不可能重新从slow+1开始遍历，因为随着slow增加，前面的数肯定 //会继续算在ans里，所以，fast继续在老位置向后遍历。或者记住我们是查找范围不是查找值即可 for(int slow = i+1; slow &lt; len - 1; ++slow)&#123; while(fast &lt; len &amp;&amp; nums[fast] &lt; nums[slow] + nums[i])&#123; //等到fast == i + slow时，就不满足条件了 fast++; &#125; ans += Math.max(fast - slow-1, 0); //[slow,fast],这个区间的数都表示第三边小于两边之和 &#125; &#125; return ans;&#125; 左右指针一般的左右指针都是二分查找，详细内容可见二分查找笔记。 下面给出三个不是二分查找的，是左右指针比较，然后进行相应的处理， 125. 验证回文串12345678910111213141516public boolean isPalindrome(String s) &#123; int left = 0, right = s.length()-1; while(left &lt; right)&#123; while(left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left)))&#123; //去掉除去不是数字或字母的 left++; &#125; while(left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right)))&#123; right--; &#125; //化成小写字母再判断 if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) return false; left++; right--; &#125; return true;&#125; 新解法：下面增加两个相似的算法 12345678910111213while(left &lt; right)&#123; while(left &lt; right)&#123; //处理left字符，直至满足题目要求 &#125; while(left &lt; right)&#123; //处理Right字符，直至满足题目要求 &#125; //比较left和左右字符 //不满足条件返回fasle&#125;return true; 125. 验证回文串12345678910111213141516171819202122232425public boolean isPalindrome(String s) &#123; int left = 0, right = s.length()-1; while(left &lt; right)&#123; while(left &lt; right)&#123; if(!Character.isLetterOrDigit(s.charAt(left)))&#123; left++; &#125;else&#123; break; &#125; &#125; while (left &lt; right)&#123; if(!Character.isLetterOrDigit(s.charAt(right)))&#123; right--; &#125;else&#123; break; &#125; &#125; if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right)))&#123; return false; &#125; left++; right--; &#125; return true;&#125; 844. 比较含退格的字符串12345678910111213141516171819202122232425262728293031323334353637383940public boolean backspaceCompare(String s, String t) &#123; int sLen = s.length(), tLen = t.length(); int sIndex = sLen-1, tIndex = tLen-1; int skipS = 0, skipT = 0; while(sIndex &gt;= 0 || tIndex &gt;= 0)&#123; while(sIndex &gt;= 0)&#123; if(s.charAt(sIndex) == &#x27;#&#x27;)&#123; skipS++; sIndex--; &#125;else if(skipS &gt; 0)&#123; skipS--; sIndex--; &#125;else&#123; break; &#125; &#125; while(tIndex &gt;= 0)&#123; if(t.charAt(tIndex) == &#x27;#&#x27;)&#123; skipT++; tIndex--; &#125;else if(skipT &gt; 0)&#123; skipT--; tIndex--; &#125;else&#123; break; &#125; &#125; if(sIndex &gt;= 0 &amp;&amp; tIndex &gt;= 0)&#123; if(s.charAt(sIndex) != t.charAt(tIndex))&#123; return false; &#125; &#125;else&#123; if(sIndex &gt;= 0 || tIndex &gt;= 0)&#123; return false; //表示有一个走到底了 &#125; &#125; sIndex--; tIndex--; &#125; return true; 977. 有序数组的平方123456789101112131415161718public int[] sortedSquares(int[] nums) &#123; int left = 0, right = nums.length-1; int len = nums.length; int index = len - 1; int[] arr = new int[len]; while(left &lt;= right)&#123; if(nums[left] + nums[right] &lt; 0)&#123; //表示左边绝对值更大 arr[index] = nums[left] * nums[left]; left++; &#125;else&#123; arr[index] = nums[right] * nums[right]; right--; &#125; index--; &#125; return arr;&#125; 15. 三数之和1234567891011121314151617181920212223242526272829303132public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); //排序 int len = nums.length; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; len -2; ++i)&#123; if(nums[i] &gt; 0) return ans; //当三元组第一个大于0，表示为后面不可能为0 //去重,重复的元素不能一直用 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; int left = i+1, right = nums.length-1; while(left &lt; right)&#123; if(nums[i] + nums[left] + nums[right] &lt; 0)&#123; //表示left小了 left++; &#125;else if(nums[i] + nums[left] + nums[right] &gt; 0)&#123; right--; &#125;else&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); ans.add(list); while(left &lt; right &amp;&amp; nums[left] == nums[left+1]) left++; //去重 while(left &lt; right &amp;&amp; nums[right] == nums[right-1]) right--; left++; right--; &#125; &#125; &#125; return ans;&#125;","categories":[],"tags":[]},{"title":"二分查找","slug":"二分查找","date":"2022-03-22T13:05:15.905Z","updated":"2022-03-30T02:11:43.245Z","comments":true,"path":"二分查找/","link":"","permalink":"http://bionic-sheep.github.io/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二分查找是一个高效率的查找方法，通常应用在顺序存储结构，且关键字有序。 查找过程： 将搜索空间中间的数mid与target比较 当mid数小于target说明target在搜索空间右边，将[mid+1-right]作为搜索空间，当mid数大于target说明target在搜索空间左边，将left-mid-1作为搜索空间。 重复1.2步骤，直至发现target或搜索空间为0 核心思想：不断的缩短搜索空间来寻值。 基本方法左闭右闭和左闭右开 1234567891011121314public int search(int[] nums, int target) &#123; //最简单的模板 int left = 0, right = nums.length-1; while(left &lt;= right)&#123; // [left, right] int mid = left + (right - left)/2; if(nums[mid] == target) return mid; else if(nums[mid] &gt; target)&#123; right = mid -1; //nums[mid]参与了运算，即[left, mid]结束搜索，下一个搜索空间为[mid+1,right] &#125;else&#123; left = mid + 1; //同理,[mid, right]结束搜索，下一个搜索空间为[left, mid-1] &#125; &#125; return -1; &#125; 12345678910111213public int search(int[] nums, int target) &#123; int left = 0 ,right = nums.length; while(left &lt; right)&#123; //[left, right)，因为right = nums.length 表示nums[right]是不存在的数 int mid = (left + right)/2; if(nums[mid] == target) return mid; else if(nums[mid] &lt; target)&#123; left = mid + 1; // nums[mid]参与运算，即[left, mid]结束搜索，下一个[mid+1, right) &#125;else&#123; right = mid; //同理，[mid,right)结束，下一个搜索空间是[left, mid-1],这里为了保持左闭右开的一致性，用right表示mid-1，即[left, mid-1] == [left, mid) == [left, right) &#125; &#125; return -1; &#125; 之前不太明白左闭右开的搜索逻辑，但是在LC上看了大佬liweiwei1419的文章后才算是豁然开朗。 下面给出我做的几个二分查找LC题 35. 搜索插入位置这题算是第三个模板，只有两个判断，同过不断缩短搜索空间，最后left == right跳出循环 12345678910111213public int searchInsert(int[] nums, int target) &#123; //首先弄懂它查找的值在数组中的实际意义，找到target第一次大于等于元素的下标 int left = 0, right = nums.length; while(left &lt; right)&#123; //当left和right重合，停止搜索，即left是大于或等于的元素下标 int mid = (left+right)/2; if(nums[mid] &lt; target)&#123; left = mid + 1; //[left, mid] 小于它 [mid+1, right) &#125;else&#123; right = mid; //[mid, right) &#125; &#125; return left;&#125; 34. 在排序数组中查找元素的第一个和最后一个位置123456789101112131415161718192021222324252627282930313233343536373839public int[] searchRange(int[] nums, int target) &#123; int leftBorder = getLeftBorder(nums, target); int rightBorder = getRightBorder(nums, target); if(leftBorder == -2 || rightBorder == -2) return new int[]&#123;-1,-1&#125;; //因为它不但向一边逼近 if(rightBorder - leftBorder &gt; 1) return new int[]&#123;leftBorder+1, rightBorder-1&#125;; else return new int[]&#123;-1,-1&#125;;&#125;public int getLeftBorder(int[] nums, int target)&#123; //寻找左边界,即重复元素第一个，那么右边不断向左缩短即可 int left = 0, right = nums.length; int ans = -2; while(left &lt; right)&#123; int mid = (left+right)/2; if(nums[mid] &gt;= target)&#123; //因为是右边不断向左缩小，那么必然有相等的情况 right = mid; // [mid, right) --&gt; [left, mid-1] -- &gt;[left, mid) ans = right - 1; &#125;else&#123; left = mid + 1; //[left, mid] --&gt; [mid+1, right] &#125; &#125; return ans;&#125;public int getRightBorder(int[] nums, int target)&#123; int left = 0, right = nums.length; int ans= -2; while(left &lt; right)&#123; int mid = (left+right)/2; if(nums[mid] &lt;= target)&#123; //，如果不存该数，例如nums = [5,7,7,8,8,10], target = 6，那么不会进入下面语句 //左边向右逼近， left = mid + 1; ////[left, mid] --&gt; [mid+1, right] ans = left; &#125;else&#123; right = mid; &#125; &#125; return ans;&#125; 69. x 的平方根 1234567891011121314151617public int mySqrt(int x) &#123; // 有序，找值，k² &lt;= x 中k的最大值 int left = 0, right = x; //这里不能x/2，因为x/2，因为奇偶数不同，奇数除2会向下取整数，所以成闭区间，偶数又是开区间 int ans = 1; while(left &lt;= right)&#123; int mid = left + (right-left)/2; if((long)mid*mid &lt;= x)&#123; //应该是向右逼近， ans = mid; //ans记下当前满足条件的k left = mid + 1; &#125;else&#123; right = mid - 1; &#125; &#125; return ans;&#125; 367. 有效的完全平方数1234567891011121314151617class Solution &#123; public boolean isPerfectSquare(int num) &#123; //和x一样 int left = 0, right = num; int ans = -1; while(left &lt;= right)&#123; int mid = (right-left)/2 + left; if((long)mid*mid &lt;= num)&#123; ans = mid; left = mid + 1; &#125;else&#123; right = mid - 1; &#125; &#125; return ans*ans == num; &#125;&#125; 总结上面部分我基本只写了两种判断就是为了锻炼分析搜索空间的能力。一定要记住核心思想：不断的减小搜索空间。 解题首要要判断我们到底要找的是什么样的值，有哪些特征。 比如说35.搜索插入位置，我们要找到值是一个大于等于target的元素下标。 当前左边所有的搜索空间均小于它，那么反过来，随着搜索空间的减小，mid+1是不是最终就大于等于target 12if(nums[mid] &lt; target)&#123; left = mid + 1; //[left, mid] 小于它 [mid+1, right) 同理,右边所有的搜索空间均大于等于它，那么最终left == right的时候，right就停在了大于等于target的元素下标的位置 123else&#123; right = mid; //[mid, right) &#125; 所以最后返回 left或right均可。 34,69,367问题都是类似，都是找元素下标，34左边找第一个target下标，右边找最后一个target下边，69和367是一样的问题，34找k²&lt;=x的最大值k,367找k²==x。都是逐步减小搜索空间，然后逼近。仔细体会","categories":[],"tags":[]},{"title":"ArrayList和LinkedList","slug":"ArrayList和LinkedList","date":"2022-03-20T08:06:07.746Z","updated":"2022-03-30T02:11:05.001Z","comments":true,"path":"ArrayList和LinkedList/","link":"","permalink":"http://bionic-sheep.github.io/ArrayList%E5%92%8CLinkedList/","excerpt":"","text":"Collection接口的常用方法 123456789boolean add(E e); // 向集合中添加一个元素boolean addAll(Collection c); //添加集合中的所有元素void clean(); //清理集合中所有元素，集合长度为0boolean contains(Object o); //判断集合中是否存在指定元素boolean isEmpty(); // 判空boolean remove(Object o); //删除指定元素，当集合包含多个元素o，值删除第一个符合条件的元素。int size();Object[] toArray();//转换为响应的数组boolean retainAll(); //保留集合中相同的元素，其余删除 重点 排序操作 123456void reverse(List list); //反转void shuffle(List list);//随机排序void sort(List list);//按自然排序升序void sort(List list, Comparator c); //定制排序void swap(List list, int i, int j);//交换两个索引位置的元素void rotate(List list, int distance); //旋转，当distance为正数，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面 查找、替换 1234567int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素int frequency(Collection c, Object o)//统计元素出现次数int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素 List有序、可重复的集合。 实现类：ArrayList和LinkedList ArrayList实现可变数组大小，快速基于索引访问元素的方式，即随机访问，删除和插入元素相对较慢 12345E get(int index);//获取index下标元素int index(Object o); //返回第一次出现指定元素的索引 不存在返回-1int lastIndexOf(Object o); //返回最后一次出现指定元素的索引 不存在返回-1E set(int index, E element); //将此索引位置元素修改为elements参数指定的对象List&lt;E&gt; subList(int fromIndex, int toIndex); //返回两个参数索引之间的所有元素 LinkedList采用链表保存对象，便于向集合中插入或者删除元素 123456void addFirst(E e); //将指定元素添加到此集合的开头void addLast(E e); //将指定元素添加到此集合的末尾E getFirst(); //返回首元素E getLast(); //返回尾元素E removeFirst(); //删除首元素E removeLast(); //删除为元素 ArrayList和LinkedList的区别都是List接口的实现类，都实现了List的方法，只是实现的方式不同。 ArrayList是基于动态数组数据结构实现的，在元素访问上更胜一筹，因为数组在内存上的存储是连续的，但是链表是离散的，需要根据上下游标去查询 LinkedList是基于链表数据结构实现的，占用内存空间大，但在删除和增加元素上更好，可扩展性更好。","categories":[],"tags":[]},{"title":"hexo + github 显示404 There isn't a GitHub Pages site here.","slug":"hexo + github 显示404 There isn't a GitHub Pages site here","date":"2022-03-20T05:00:07.280Z","updated":"2022-03-30T02:10:48.964Z","comments":true,"path":"hexo + github 显示404 There isn't a GitHub Pages site here/","link":"","permalink":"http://bionic-sheep.github.io/hexo%20+%20github%20%E6%98%BE%E7%A4%BA404%20There%20isn't%20a%20GitHub%20Pages%20site%20here/","excerpt":"","text":"我是按照https://www.nowcoder.com/discuss/657562?type=0&amp;order=7&amp;pos=8&amp;page=1&amp;channel=1009&amp;source_id=discuss_center_0_nctrack 这篇文章来搭建博客的，在部署的过程中一直显示错误，最后 在这反应过来了，这里的意思应该是你github的用户名，我的用户名叫bionic-sheep，但是我的仓库名叫sheep。 最后在 这个地方改过来之后就好了。 刚好当做博客的第一篇博文","categories":[],"tags":[]},{"title":"comparable 和 comparator","slug":"comparable 和 comparator","date":"2021-09-04T14:52:18.527Z","updated":"2022-03-30T02:13:05.754Z","comments":true,"path":"comparable 和 comparator/","link":"","permalink":"http://bionic-sheep.github.io/comparable%20%E5%92%8C%20comparator/","excerpt":"","text":"Comparable接口的 - 自然排序 像String 、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式 重写compareTo(obj)规则 对于自定义类来说，如果需要排序： 首先实现 Comparable接口 其次重写CompareTo(obj)方法 //String、包装类的排序：不需要自己重写compareTo(obj)方法。类已经写好了 123456789@Test public void test1()&#123; String[] arr = new String[]&#123;&quot;AA&quot;, &quot;CC&quot;, &quot;KK&quot;, &quot;MM&quot;, &quot;GG&quot;&#125;; Arrays.sort(arr); System.out.println(Arrays.toString(arr)); &#125; //自定义类：需要自己重写 12345678910111213141516171819202122232425262728293031323334353637public class CompareTest &#123;@Test public void test2()&#123; Goods[] arr = new Goods[4]; arr[0] = new Goods(&quot;apple&quot;, 34); arr[1] = new Goods(&quot;xiaomi&quot;, 12); arr[2] = new Goods(&quot;huawei&quot;, 24); arr[3] = new Goods(&quot;lenven&quot;,22); Arrays.sort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125;public class Goods implements Comparable&#123; ...//省略类的属性、构造方法、getset方法 //重写compareTo(obj)方法 @Override public int compareTo(Object o) &#123; if( o instanceof Goods)&#123;//强转 Goods goods =(Goods)o; if(this.price &lt; goods.price)&#123; return 1; //返回正数 goods更大 &#125;else if(this.price &gt; goods.price)&#123; return -1; &#125;else&#123; return 0; &#125; //方式二 // return Double.compare(this.price, goods.price); &#125; throw new RuntimeException(&quot;传入的数据类型不一致！&quot;); &#125; &#125; 快捷键alt ＋ insert 可以插入构造器。get set toString equals等方法 Comparato接口-定制排序 背景：当元素的类型没有实现java.lang.Comparable接口但又不方便修改代码，或者当前接口的排序规则不符合当前操作，就使用Comparato的对象来排序 重写compare(Object o1, Object o2)方法，比较o1和o2的大小：如果方法返回正整数，o1 大于 o2; 0 则相等 否则o1 小于 o2 12345678910111213141516171819@Test public void test3()&#123; String[] arr = new String[]&#123;&quot;AA&quot;, &quot;CC&quot;, &quot;KK&quot;, &quot;MM&quot;, &quot;GG&quot;&#125;; Arrays.sort(arr, new Comparator&lt;String&gt;() &#123; //自定义排序 //按照字符串从大到小排序 @Override public int compare(String o1, String o2) &#123; if(o1 instanceof String &amp;&amp; o2 instanceof String)&#123;//强转数据类型 String s1 = (String) o1; String s2 = (String) o2; return -s1.compareTo((s2)); &#125; throw new RuntimeException(&quot;输入类型不一致！&quot;); &#125; &#125;); System.out.println(Arrays.toString(arr)); &#125; 12345678910111213141516171819202122232425262728293031//自定义类@Test public void test4()&#123; Goods[] arr = new Goods[6]; arr[0] = new Goods(&quot;apple&quot;, 34); arr[1] = new Goods(&quot;xiaomi&quot;, 12); arr[2] = new Goods(&quot;huawei&quot;, 34); arr[3] = new Goods(&quot;lenven&quot;,22); arr[4] = new Goods(&quot;lenven&quot;,223); arr[5] = new Goods(&quot;lenven1&quot;,12); Arrays.sort(arr, new Comparator&lt;Goods&gt;() &#123; //按照产品名称从低到高排序，再按价格从高到低 @Override public int compare(Goods o1, Goods o2) &#123; if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods)&#123; Goods g1 = (Goods) o1; Goods g2 = (Goods) o2; if(g1.getName().equals(g2.getName()))&#123; //品牌一样 return -Double.compare(g1.getPrice(), g2.getPrice()); &#125;else&#123; return g1.getName().compareTo((g2.getName())); &#125; &#125; throw new RuntimeException(&quot;数据类型输入错误！&quot;); &#125; &#125;); System.out.println(Arrays.toString(arr)); &#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}