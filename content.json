{"meta":{"title":"Sheep","subtitle":"Do what u love, love what u do","description":null,"author":"Bionic-Sheep","url":"http://Bionic-Sheep.github.io","root":"/"},"pages":[{"title":"about","date":"2022-04-03T02:14:21.000Z","updated":"2022-04-03T02:14:50.811Z","comments":true,"path":"about/index.html","permalink":"http://bionic-sheep.github.io/about/index.html","excerpt":"","text":"自我介绍：研二在读"}],"posts":[{"title":"二叉树算法题总结","slug":"二叉树遍历总结","date":"2022-05-02T07:43:15.516Z","updated":"2022-05-02T07:52:47.644Z","comments":true,"path":"二叉树遍历总结/","link":"","permalink":"http://bionic-sheep.github.io/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"二叉树总结二叉树的遍历二叉树的遍历可分为两种，深度优先遍历和广度优先遍历 其中这两种遍历又可发散为三种深度优先遍历和一种广度优先遍历 前序遍历：根左右 中序遍历：左根右 后序遍历：左右根 和 层序遍历 深度优先遍历递归其中深度优先遍历的递归写法最好写，下面给出总的递归遍历，基本都能懂。 123456789 void dfs(TreeNode root)&#123; if(root != null)&#123; ...; //根，前序遍历 dfs(root.left); //左 ...; //根，中序遍历 dfs(root.right); //右 ...; //根，后序遍历 &#125; &#125; 迭代前序遍历迭代，最简单，出栈节点即访问节点和处理节点 1234567891011121314151617 class Solution &#123; //迭代 public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if(root == null) return ans; Stack&lt;TreeNode&gt; stack = new Stack(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); ans.add(node.val); if(node.right != null) stack.push(node.right); if(node.left != null) stack.push(node.left); &#125; return ans; &#125; &#125; 中序 中序遍历，左根右，需要一直左移到null，然后弹出来，处理，然后右子树入栈，再左移右子树第一个。然后依次入栈弹栈接着上面步骤处理，直到结束。 1234567891011121314151617 class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;(); while(root != null || !stack.isEmpty())&#123; if(root != null)&#123; stack.push(root); root = root.left; &#125;else&#123; root = stack.pop(); ans.add(root.val); root = root.right; &#125; &#125; return ans; &#125; &#125; 后序 左右根 123456789101112131415161718192021222324252627 class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if(root == null) return ans; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = null; while(root != null || !stack.isEmpty())&#123; //左子树不为空，入栈 while(root != null)&#123; stack.push(root); root = root.left; &#125; root = stack.pop(); if(root.right == null || root.right == node)&#123; //如果右子树也为空，表叶子节点，则访问，或者曾经访问过该节点 ans.add(root.val); node = root; root = null; &#125;else&#123; stack.push(root); root = root.right; &#125; &#125; return ans; &#125; &#125; 可得三种遍历顺序各不相同，很麻烦。 统一迭代下面给出一种三种遍历的统一迭代写法 也是一种递归的思想，采取了栈实现。 栈的特性是先进后出，所以遍历顺序与入栈顺序相反。例如，前序是，根左右，那么入栈就是右左根。 这是一种统一标记法，思想是每个节点会入栈两次，节点A第一次入栈是因为与其他节点有附属关系，被动入栈，第二次入栈会将节点A做上null标记，然后重新调整节点的入栈顺序。比如，当前栈顶元素不是null标记，假设是前序遍历，那么会弹出这个节点，然后先将该节点的右子树入栈，再将该节点左子树入栈，最后将该节点入栈并做上Null标记，这就是它的第二次入栈，是为了调整它子树的入栈顺序。 代码 1234567891011121314151617181920212223242526272829303132333435363738 class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if(root == null) return ans; stack.push(root); //第一次入栈 while(!stack.isEmpty())&#123; TreeNode node = stack.peek(); //判断当前节点是否为空 if(node != null)&#123; node = stack.pop(); //出栈 //根据栈特性，先进后出，前序遍历顺序前左右，可以得知入栈顺序，右左前// **后序** stack.push(node); //入栈，第二次入栈 stack.push(null); //标记 if(node.right != null) stack.push(node.right);// **中序** stack.push(node); //入栈，第二次入栈 stack.push(null); //标记 if(node.left != null) stack.push(node.left); //**前序** stack.push(node); //入栈，第二次入栈 stack.push(null); //标记 &#125;else&#123; stack.pop(); //弹出null node = stack.pop(); ans.add(node.val); &#125; &#125; return ans; &#125; &#125; 层序遍历根据队先进先出的顺序，层序遍历用队列从左到右的入队，然后处理每个节点 1234567891011121314151617181920 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if(root == null) return list; Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;(); //队列 que.offer(root); //入队 while(!que.isEmpty())&#123; int size = que.size(); //这里要注意，要将size提出来，因为随着队列不断入队出队，队列的长度时变化的，用size固定 List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; size; ++i)&#123; TreeNode node = que.poll(); ans.add(node.val); //处理节点，即访问节点 if(node.left != null) que.offer(node.left); if(node.right != null) que.offer(node.right); &#125; list.add(ans); &#125; return list; &#125; &#125; 层序遍历问题，基本上掌握了上面的代码，lc上的层序遍历题就没大问题。 102. 二叉树的层序遍历 107. 二叉树的层序遍历 II 199. 二叉树的右视图 637. 二叉树的层平均值 429. N 叉树的层序遍历 515. 在每个树行中找最大值 116. 填充每个节点的下一个右侧节点指针 117. 填充每个节点的下一个右侧节点指针 II 104. 二叉树的最大深度 111. 二叉树的最小深度 103. 二叉树的锯齿形层序遍历 ****993. 二叉树的堂兄弟节点这个题挺巧妙的，可以做一下** / 上面都是层序遍历的模板题，基本上没有变化。可能根据题意在不同的地方做出不同的处理就完成。 下面给出一些深度优先遍历的leetcode题 前序遍历226. 翻转二叉树123456789101112131415class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root == null) return null; //处理的单层逻辑 TreeNode node = root.left; root.left = root.right; root.right = node; //左右递归 invertTree(root.left); invertTree(root.right); return root; &#125;&#125; 101. 对称二叉树123456789101112131415class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; if(root == null) return true; return isTrue(root.left,root.right); &#125; //递归函数：返回值-boolean 保证下面的为正确，参数为root.left 和 root.right public boolean isTrue(TreeNode left, TreeNode right)&#123; //终止条件 if(left == null &amp;&amp; right == null) return true; else if(left == null || right == null) return false; else if(left.val != right.val) return false; //剩下的当前值相同，比较下面的结构是否相同 return isTrue(left.left,right.right) &amp;&amp; isTrue(left.right,right.left); &#125;&#125; 110. 平衡二叉树自上而下~前序遍历 12345678910111213141516171819202122class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root == null) return true; //单层处理逻辑 int l = deep(root.left); int r = deep(root.right); if(l - r &gt; 1 || l - r &lt; -1) return false; //左右遍历 boolean l1 = isBalanced(root.left); boolean r1 = isBalanced(root.right); return l1 &amp;&amp; r1; &#125; public int deep(TreeNode root)&#123; if(root == null) return 0; return Math.max(deep(root.left), deep(root.right)) + 1; &#125;&#125; 222. 完全二叉树的节点个数前序遍历，主要是根据完全二叉树的特性 1234567891011121314151617181920212223242526class Solution &#123; public int countNodes(TreeNode root) &#123; //迭代用层序遍历很好求 if(root == null) return 0; TreeNode left = root.left; TreeNode right = root.right; int l = 0, r = 0; while(left != null)&#123; left = left.left; l++; &#125; while(right != null)&#123; right = right.right; r++; &#125; if(l == r)&#123; return (2 &lt;&lt; l) - 1; &#125; return countNodes(root.left) + countNodes(root.right) + 1; &#125;&#125; 100. 相同的树123456789101112class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; //单层处理逻辑 boolean flag = p.val == q.val; return flag &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125; &#125; 572. 另一棵树的子树12345678910111213141516class Solution &#123; public boolean isSubtree(TreeNode root, TreeNode subRoot) &#123; //首先创建一个判断是否相同的子树的函数，然后不断的用root的左右子树不断和subRoot比较，找到一个true既可 if(root == null) return false; if(subRoot == null) return true; //**isSame函数就是单层处理逻辑，判断两个树是否相同，然后左右递归** return isSame(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); &#125; public boolean isSame(TreeNode p, TreeNode q)&#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; return p.val == q.val &amp;&amp; isSame(p.left, q.left) &amp;&amp; isSame(p.right, q.right); &#125;&#125; 617. 合并二叉树1234567891011121314class Solution &#123; public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123; if(root1 == null) return root2; if(root2 == null) return root1; //前序遍历的单层逻辑 root1.val = root1.val + root2.val; root1.left = mergeTrees(root1.left, root2.left); root1.right = mergeTrees(root1.right, root2.right); return root1; &#125;&#125; 993. 二叉树的堂兄弟节点12345678910111213141516171819202122232425262728class Solution &#123; TreeNode xParent, yParent; int xDeep, yDeep; int x, y; public boolean isCousins(TreeNode root, int x, int y) &#123; this.x = x; this.y = y; dfs(null, root, 1); return xDeep == yDeep &amp;&amp; xParent != yParent; &#125; public void dfs(TreeNode parent, TreeNode root, int deep)&#123; if(root == null) return; if(root.val == x)&#123; xDeep = deep; xParent = parent; &#125; if(root.val == y)&#123; yDeep = deep; yParent = parent; &#125; dfs(root, root.left, deep+1); dfs(root, root.right, deep+1); &#125;&#125; 回溯257. 二叉树的所有路径12345678910111213141516171819202122232425class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); if(root == null) return ans; backtracking(root, &quot;&quot;, ans); return ans; &#125; public void backtracking(TreeNode root, String str, List&lt;String&gt; ans)&#123; //说明该节点为叶子节点,满足终止条件 if(root.left == null &amp;&amp; root.right == null)&#123; str += root.val; ans.add(str); return; &#125; if(root.left != null)&#123; backtracking(root.left, str + root.val + &quot;-&gt;&quot;, ans); //回溯 &#125; if(root.right != null)&#123; backtracking(root.right, str + root.val + &quot;-&gt;&quot;, ans); &#125; &#125;&#125; 513. 找树左下角的值123456789101112131415161718192021222324252627class Solution &#123; int max = -1; int ans = 0; public int findBottomLeftValue(TreeNode root) &#123; if(root == null) return 0; find(root, 0); return ans; &#125; public void find(TreeNode root, int deep)&#123; //当前节点为叶子节点 if(root.left == null &amp;&amp; root.right == null)&#123; if(max &lt; deep)&#123; max = deep; ans = root.val; &#125; &#125; if(root.left != null)&#123; find(root.left, deep+1); //回溯体现在deep+1 &#125; if(root.right != null)&#123; find(root.right, deep+1); &#125; &#125;&#125; 112. 路径总和123456789101112131415161718192021222324class Solution &#123; boolean flag = false; public boolean hasPathSum(TreeNode root, int targetSum) &#123; if(root == null) return false; dfs(root, targetSum); return flag; &#125; public void dfs(TreeNode root, int sum)&#123; if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val)&#123; flag = true; &#125; if(root.left != null)&#123; dfs(root.left, sum - root.val); &#125; if(root.right != null)&#123; dfs(root.right, sum - root.val); &#125; &#125;&#125; 113. 路径总和 II1234567891011121314151617181920212223242526272829303132class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return ans; backtracking(root, targetSum, ans, list); return ans; &#125; public void backtracking(TreeNode root, int sum, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list)&#123; if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val)&#123; list.add(root.val); ans.add(new ArrayList&lt;&gt;(list)); list.remove(list.size()-1); return; &#125; if(root.left != null)&#123; list.add(root.val); backtracking(root.left, sum - root.val, ans, list); list.remove(list.size()-1); &#125; if(root.right != null)&#123; list.add(root.val); backtracking(root.right, sum - root.val, ans, list); list.remove(list.size()-1); &#125; &#125;&#125; 后序遍历104. 二叉树的最大深度1234567891011class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null) return 0; //叶子节点了，为0 //查询作业子树的深度 //后序遍历 int left = maxDepth(root.left); int right = maxDepth(root.right); //单层处理逻辑 return Math.max(left, right) + 1; &#125;&#125; 404. 左叶子之和1234567891011121314class Solution &#123; public int sumOfLeftLeaves(TreeNode root) &#123; if(root == null) return 0; int sum = 0; if(root.left != null)&#123; if(root.left.left == null &amp;&amp; root.left.right == null)&#123; //左叶子 sum = root.left.val; &#125; &#125; return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right) + sum; &#125;&#125; 111. 二叉树的最小深度需要限制条件 123456789101112131415class Solution &#123; public int minDepth(TreeNode root) &#123; if(root == null) return 0; if(root.left != null &amp;&amp; root.right == null)&#123; return 1 + minDepth(root.left); &#125; if(root.right != null &amp;&amp; root.left == null)&#123; return 1 + minDepth(root.right); &#125; return Math.min(minDepth(root.right), minDepth(root.left)) + 1; &#125;&#125; 110. 平衡二叉树自下而上~后序遍历 1234567891011121314151617181920class Solution &#123; public boolean isBalanced(TreeNode root) &#123; return height(root) != -1; &#125; //高度：该节点到叶子节点的最长简单路径 public int height(TreeNode root)&#123; if(root == null) return 0; int leftHeight = height(root.left); //拿到子树的高度 if(leftHeight == -1) return -1; int rightHeight = height(root.right); if(rightHeight == -1) return -1; if(Math.abs(leftHeight - rightHeight) &gt; 1) return -1; return Math.max(leftHeight, rightHeight) + 1; &#125;&#125; 构造二叉树模板123456789101112131415161718//模板构造函数因为一般都是数组构造二叉树，所以left和right的二叉树的范围，因为我定义其他的东西都是全局变量，所以形参只有两个比较方便。TreeNode dfs(int left, int right)&#123; if(left &gt; right) return; //不满足范围，表示构造不了二叉树 index...确定当前的节点的下标 value...根据下标找到数组中的值，然后构造树节点 TreeNode root = new TreeNode(value) //root节点的左右顺序需要根据题目来确定 root.left = dfs(left, index-1); root.right = dfs(index+1, right); return root;&#125; 106. 从中序与后序遍历序列构造二叉树主要是明白中序和后序构造二叉树的原理，后序数组从后遍历，每次都是中序数组当前的根节点。 怎么从知道中序数组根节点的值，到值的下标，采用哈希来记录，这样就可以根据后序数组最后一个值，知道中序根节点的下标来，分割数组 12345678910111213141516171819202122232425262728293031323334class Solution &#123; int[] inorder; int[] postorder; int len; Map&lt;Integer, Integer&gt; map; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; this.inorder = inorder; this.postorder = postorder; this.len = postorder.length-1; //后序数组的最后一个，即中序数组当前的根节点 this.map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; inorder.length; ++i)&#123; map.put(inorder[i], i); //map存放中序数组的值及下标 &#125; return dfs(0, len); &#125; public TreeNode dfs(int left, int right)&#123; if(left &gt; right) return null; //先拿到后序节点的值，再去匹配中序数组 int val = postorder[len]; //中序数组的当前根节点 int index = map.get(val); //中序数组的根节点下标 TreeNode root = new TreeNode(val); //根节点 len--; //换新根节点 //先右后左，是根据后序遍历数组的根节点分布来的 root.right = dfs(index+1, right); root.left = dfs(left, index-1); return root; &#125;&#125; 同理，105. 从前序与中序遍历序列构造二叉树 654. 最大二叉树1234567891011121314151617181920212223242526class Solution &#123; int[] nums; public TreeNode constructMaximumBinaryTree(int[] nums) &#123; this.nums = nums; return backtracking(0, nums.length-1); &#125; public TreeNode backtracking(int left , int right)&#123; if(left &gt; right) return null; int index = left; for(int i = left; i &lt;= right; ++i)&#123; if(nums[index] &lt; nums[i])&#123; index = i; &#125; &#125; TreeNode root = new TreeNode(nums[index]); root.left = backtracking(left, index-1); root.right = backtracking(index+1, right); return root; &#125;&#125; 108. 将有序数组转换为二叉搜索树12345678910111213141516171819202122class Solution &#123; int[] nums; public TreeNode sortedArrayToBST(int[] nums) &#123; this.nums = nums; return build(0, nums.length-1); &#125; public TreeNode build(int left, int right)&#123; if(left &gt; right) return null; int mid = (left + right) &gt;&gt; 1; TreeNode root = new TreeNode(nums[mid]); root.left = build(left, mid-1); root.right = build(mid+1, right); return root; &#125;&#125; 二叉搜索树性质1： 若任意结点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值。 若任意结点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值。 任意结点的左、右子树也分别为二叉搜索树。 性质2: 中序遍历二叉搜索树具有有序性。 700. 二叉搜索树中的搜索根据二叉搜索树的特性，我们在递归这棵树树，有了方向性，根节点总是大于左边，小于右边。 12345678class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; if(root == null) return null; if(root.val &gt; val) return searchBST(root.left, val); else if(root.val &lt; val) return searchBST(root.right, val); else return root; &#125;&#125; 98. 验证二叉搜索树性质1：前序遍历，不断的向下判断当前的root是否满足范围， 123456789101112class Solution &#123; public boolean isValidBST(TreeNode root) &#123; return dfs(root, Long.MIN_VALUE, Long.MAX_VALUE); &#125; public boolean dfs(TreeNode root, long low,long high)&#123; if(root == null) return true; if(root.val &lt;= low || root.val &gt;= high) return false; return dfs(root.left, low, root.val) &amp;&amp; dfs(root.right, root.val, high); &#125;&#125; 性质2：中序遍历，采用pre记住上一个节点是关键。 123456789101112131415161718192021class Solution &#123; TreeNode pre = null; boolean flag = true; public boolean isValidBST(TreeNode root) &#123; inorder(root); return flag; &#125; public void inorder(TreeNode root)&#123; if(root == null) return; inorder(root.left); if(pre != null &amp;&amp; pre.val &gt;= root.val)&#123; flag = false; &#125; pre = root; inorder(root.right); &#125;&#125; 中序遍历中序遍历二叉搜索树具有有序性，依此性质可以消灭很多类似的题 模板 12345678910111213141516171819TreeNode pre = null; //全局变量，用于记住上一个节点.... //满足某些特定题目规则所作的变量... main()&#123;&#125; //主函数void inorder(TreeNode root)&#123; if(root == null) return; inorder(root.left); if(pre != null)&#123; //表示不是中序遍历最后一个节点 ... //完成某种规则所需的操作 &#125; pre = root; //记住上一个节点 inorder(root.right);&#125; 530. 二叉搜索树的最小绝对差123456789101112131415161718class Solution &#123; TreeNode pre = null; int ans = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) &#123; if(root == null) return 0; dfs(root); return ans; &#125; public void dfs(TreeNode root)&#123; if(root == null) return; dfs(root.left); if(pre != null &amp;&amp; ans &gt; root.val - pre.val) ans = root.val - pre.val; pre = root; dfs(root.right); &#125;&#125; 501. 二叉搜索树中的众数1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; TreeNode pre = null; int count = 1; int max = 1; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public int[] findMode(TreeNode root) &#123; inorder(root); int[] ans = new int[list.size()]; for(int i = 0; i &lt; list.size(); ++i)&#123; ans[i] = list.get(i); &#125; return ans; &#125; public void inorder(TreeNode root)&#123; if(root == null) return ; inorder(root.left); if(pre != null)&#123; if(pre.val == root.val)&#123; count++; &#125;else&#123; count = 1; &#125; &#125; if(count == max)&#123; list.add(root.val); &#125; if(count &gt; max)&#123; list.clear(); //清除集合 list.add(root.val); max = count; &#125; pre = root; //记住上一个节点 inorder(root.right); &#125;&#125; 538. 把二叉搜索树转换为累加树1234567891011121314151617181920212223class Solution &#123; //中序遍历有序，累加从后累加，那改成逆中序遍历即可 TreeNode pre = null; public TreeNode convertBST(TreeNode root) &#123; inorder(root); return root; &#125; public void inorder(TreeNode root)&#123; if(root == null) return; inorder(root.right); if(pre != null)&#123; root.val += pre.val; &#125; pre = root; inorder(root.left); &#125;&#125; 插入删除主要考察二叉搜索树的性质 701. 二叉搜索树中的插入操作12345678910class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if(root == null) return new TreeNode(val); if(root.val &gt; val) root.left = insertIntoBST(root.left, val); if(root.val &lt; val) root.right = insertIntoBST(root.right, val); return root; &#125;&#125; 450. 删除二叉搜索树中的节点12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if(root == null) return root; if(root.val == key)&#123; //找到删除节点了 if(root.left == null &amp;&amp; root.right == null)&#123; //叶子节点，直接删除 return null; &#125;else if(root.left == null)&#123; //左边为空 return root.right; &#125;else if(root.right == null)&#123; //右边为空 return root.left; &#125;else&#123; TreeNode node = root.right; while(node.left != null)&#123; node = node.left; &#125; node.left = root.left; //这不是指针，只是node.left指向root.left return root.right; &#125; &#125; if(root.val &gt; key)&#123; root.left = deleteNode(root.left, key); &#125; if(root.val &lt; key)&#123; root.right = deleteNode(root.right, key); &#125; return root; &#125;&#125; 669. 修剪二叉搜索树1234567891011121314151617class Solution &#123; public TreeNode trimBST(TreeNode root, int low, int high) &#123; if(root == null) return null; //当前节点小于low，那么说明这个节点及左子树修剪，继续修建右边 if(root.val &lt; low) return trimBST(root.right, low, high); //当前节点大于high，那么说明这个节点及右子树修剪，继续修建左边 if(root.val &gt; high) return trimBST(root.left, low, high); //合格 root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; &#125;&#125;","categories":[],"tags":[]},{"title":"Java内存区域与内存溢出异常","slug":"Java内存区域","date":"2022-04-03T13:07:57.846Z","updated":"2022-04-03T13:23:25.970Z","comments":true,"path":"Java内存区域/","link":"","permalink":"http://bionic-sheep.github.io/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/","excerpt":"","text":"Java内存区域与内存溢出异常运行时数据区 什么是Java字节码？Java源代码经过编译器编译后产生的文件，只面向虚拟机。这也是Java跨平台性的原因，一次编译到处运行。在虚拟机上执行。 优点：字节码不针对特定机器，只面向虚拟机执行，因此不用重新编译就可以在不同的计算机上运行。 1Java源码--&gt;编译--&gt;字节码.class文件，即JVM可执行的Java字节码--&gt;JVM--&gt;JVM解释器--&gt;二进制码--&gt;程序运行 Java的内存区域程序计数器 当前线程所执行字节码的行号指示器，程序的基础功：分支、循环、跳转都依赖它 为什么需要程序计数器？ 因为Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式实现的，一个处理器执行一条线程指令，为了在线程切换后恢复到正确的执行位置，每个线程需要一个独立的程序计数器 线程执行Java方法：记录虚拟器字节码指令地址，本地方法：值为空 虚拟机栈|本地方法栈创建一个线程就会创建一个虚拟机栈，每个方法被执行或调用时，就会创建一个栈帧放入虚拟机栈中，存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法被调用完，就对应了一个栈帧入栈到出栈的过程。 本地方法栈执行的是本地方法，作用和虚拟机栈类似 堆线程共享的一块区域，在虚拟机启动时创建，唯一目的是存放对象实例。 垃圾收集在堆上进行，也被称为GC堆，物理上可以不连续，但逻辑上连续，可固定可扩展 注：具体的堆在后面会讲解 方法区线程共享的一块区域，存储被被虚拟机加载的信息：常量、静态变量、即时编译器、编译后的代码缓存等。 对象的创建过程以HotSpot为例 对象创建 遇到一个字节码new指令，先检查指令能否在常量池中定位到类的符号引用，再检查引用是否被类加载、解析、初始化。如果无，则执行类加载过程 分配内存将一块确定大小的内存块从Java堆中划分：指针碰撞和空闲列表 分配方式：Java堆是否规整决定的，是否规整由垃圾收集器决定，是否带有压缩整理功能。 指针碰撞：以指针为分界点，一边是空闲的内存区域，一边是使用过的内存区域。GC收集器：Serial、ParNew 空闲列表：虚拟机维护一个列表，记录那个区域是可用的，分配时，从列表找到一块够用的区域来划分。GC收集器：CMS基于清除算法。 内存分配并发问题： 初始化分配完毕，将分配到的内存区域初始化为零值（不包括对象头），保证对象的实例字段在Java代码中不需要赋值就能够使用 设置对象头设置对象是那个类的实例、如何找到类的元数据信息，对象的哈希码、对象的GC分代年龄。 构造函数经历上面四步，虚拟机认为对象已经创建完毕，接下来是按照Java程序的意图，执行构造函数，完成初始化。 对象的内存布局与访问定位内存布局：对象头、实例数据、对齐填充 对象头 存储自身运行时数据：哈希码，GC分代年龄，锁状态标志、线程持有锁、偏向线程ID、偏向时间戳 类型指针，可以通过该指针知道该对象是哪个类的实例。 实例数据存储对象真正有效的数据，在程序代码中定义的各种类型的字段内容。 对齐填充占位符作用，实例数据没有补充完成，需对齐 访问定位通过栈上的reference数据来操作堆上的数据 对象实例数据（堆）:对象中各个实例字段的数据 对象类型数据（方法区）：对象的类型、父类、实现的接口、方法等 句柄访问Java堆中有一块内存作为句柄池，reference存放的就是对象的句柄地址，包含了对象实例数据和类型数据各自的地址信息。 优点：稳定的句柄地址，移除对象值会改变句柄中的实例数据，不改变reference 缺点：两次指针移动 直接指针访问Java堆中对象的内存布局必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象的地址。 好处：访问速度快，节省指针开销","categories":[],"tags":[]},{"title":"2022.4.2 京东笔试","slug":"4.2京东笔试","date":"2022-04-02T13:42:37.889Z","updated":"2022-04-03T10:33:32.602Z","comments":true,"path":"4.2京东笔试/","link":"","permalink":"http://bionic-sheep.github.io/4.2%E4%BA%AC%E4%B8%9C%E7%AC%94%E8%AF%95/","excerpt":"","text":"第一题： 在满二叉树上行走，U上L左R右 12345678910111213141516171819202122232425262728293031323334353637383940/输入描述//第一行两个空格隔开的正整数N，X////接下来一行一个长度为N的只包含U,L,R三种字母的字符串。////对于90%的数据，1≤N≤100，1≤X＜210////对于100%的数据，1≤N≤5.105，1≤X＜230class Main&#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String str; long n; //路径 long x;//所在节点编号 while (in.hasNext()) &#123; n = in.nextInt(); x = in.nextInt(); str = in.next(); for (int i = 0; i &lt; n; ++i) &#123; char c = str.charAt(i); //拿到当前行走命令 //左孩子是 2*x 右孩子是 2*x+1 if (c == &#x27;U&#x27; || c ==&#x27;u&#x27;) &#123; x = (long)x / 2; &#125; else if (c == &#x27;R&#x27; || c == &#x27;r&#x27;) &#123; //向右走 x = (long)(2 * x + 1); &#125; else &#123; x = (long)(2 * x); &#125; &#125; System.out.println(x); &#125; &#125;&#125; 本题只过了0.91，难点就在于避免超时，一开始x的接受没有用long，只能过55，后面仔细阅读题目才发现，数据范围很大，改为long，但还是有一例数据难过，可能是字符串导致的超时。 第二题 粉刷匠：不是很理解题意，但是最多的次数为3，我判断失误，只过了0.09，但是可以先判断是否相等，相等为0,不等输出rand()mod3+1，可以得到0.81，大失误。","categories":[],"tags":[]},{"title":"2022.4.2 360笔试","slug":"4.2360笔试","date":"2022-04-02T13:35:20.845Z","updated":"2022-04-02T13:56:35.185Z","comments":true,"path":"4.2360笔试/","link":"","permalink":"http://bionic-sheep.github.io/4.2360%E7%AC%94%E8%AF%95/","excerpt":"","text":"第一题： 12345678910111213141516171819202122232425262728293031323334353637383940//判断字符串串是否对称import java.util.*;public class Main &#123; public static void main(String[] args) &#123;*/ Scanner in = new Scanner(System.in); char[] ch = &#123;&#x27;A&#x27;, &#x27;H&#x27;, &#x27;I&#x27;,&#x27;M&#x27;,&#x27;N&#x27;,&#x27;O&#x27;,&#x27;T&#x27;,&#x27;U&#x27;,&#x27;V&#x27;,&#x27;W&#x27;,&#x27;X&#x27;,&#x27;Y&#x27;&#125;; String str = &quot;&quot;; while(in.hasNext())&#123; str = in.nextLine(); int k = -1; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(char c : ch)&#123; map.put(c,1); &#125; for(char c : str.toCharArray())&#123; if(!map.containsKey(c))&#123; k = 1; break; &#125; &#125; if(k == -1)&#123; int left = 0, right= str.length()-1; while(left &lt;= right)&#123; if(str.charAt(left) != str.charAt(right))&#123; k = 1; break; &#125; left++; right--; &#125; &#125; if(k == 1) System.out.println(&quot;NO&quot;); else System.out.println(&quot;YES&quot;); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//吃鸡组队class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int t; t = in.nextInt(); while(in.hasNext())&#123; int a, b, c, d; a = in.nextInt(); b = in.nextInt(); c = in.nextInt(); d = in.nextInt(); int ans = 0; //首先将四人队补充完整 ans += d; if (a &gt;= c) &#123; //单人队的数量超过三人队，可全部扩充为四人队 ans += c; a -= c; c = 0; &#125; else &#123; ans += a; // a = 0; &#125; ans += b / 2; if (b % 2 == 0) &#123; //两人队也没了 b = 0; &#125; else &#123; b = 1; &#125; //现在的情况是d == 0, c != 0 则a == 0, c == 0,说明a还剩 //如果a很多的情况，可能存在浪费 if (c == 0) &#123; if (b == 1) &#123; if (a &gt;= 2) &#123; ans += 1; a -= 2; &#125; &#125; &#125; ans += a/4; System.out.println(ans); &#125; &#125;&#125;*/ 情况：两道题都挺简单的，都AC了，第一种反转字符串，只要排除掉非对称字符即可，第二题和leetcode上面找零钱非常类似，核心就是5美元的数量，对应到本题就是单人队的数量，以单人队来补充bc队的人数。 代码可读性很差， 因为在时间紧张的条件下，不会在意代码的优美。","categories":[],"tags":[]},{"title":"ASCII码","slug":"算法题中设置哈希数组","date":"2022-03-27T07:42:51.397Z","updated":"2022-03-30T02:11:17.049Z","comments":true,"path":"算法题中设置哈希数组/","link":"","permalink":"http://bionic-sheep.github.io/%E7%AE%97%E6%B3%95%E9%A2%98%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%93%88%E5%B8%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"当遇见字符串算法题，需要用哈希来做的话，定义各种哈希的情况 如果是小写字母或大写字母，长度为26 123int[] hash = new int[26];hash[C - &#x27;a&#x27;]++;hash[C - &#x27;A&#x27;]++; 如果有空格、字母、特殊字符，长度128 123int[] hash = new int[128];hash[C - &#x27; &#x27;]++;//从空格开始，因为ASCII码从空格开始，共128个hash[C - &#x27; &#x27;]++;","categories":[],"tags":[]},{"title":"Java中的Integer的长度判断","slug":"Java中的Integer的长度判断","date":"2022-03-26T12:55:19.944Z","updated":"2022-04-15T13:36:50.768Z","comments":true,"path":"Java中的Integer的长度判断/","link":"","permalink":"http://bionic-sheep.github.io/Java%E4%B8%AD%E7%9A%84Integer%E7%9A%84%E9%95%BF%E5%BA%A6%E5%88%A4%E6%96%AD/","excerpt":"","text":"Java中的Integer的长度判断Java的数据类型是两种： 基本数据类型:int, double…..等 引用类型：Integer，Double等 一般比较大小有两种，要么==，要么equals。 ==在比较基本数据类型时，是数值大小，比较引用类型时，是比较两个引用对象是否相等。 只有equals，不管是基本数据类型还是引用数据累心，都比较的是数值大小（或者重写equals方法的内容），所以我们在比较引用类型对象的数值大小时，尽量采用equals。 下面给个例子 123456789int a = 127, b = 127;System.out.println(a == b);// trueInteger c = 127, d = 127;System.out.println(a == b); //trueint a = 128, b = 128;System.out.println(a == b);// trueInteger c = 128, d = 128; System.out.println(a == b); //false 出现上面情况是因为Integer将[-128,127]范围的整数都提前实例化了，只要数值相等，==比较的都是同一个对象。我们可以用Integer.intValue转为基本数据类型，或者equals来比较 提前实例化：Integer作为常量时，对于-128到127之间的数，会进行缓存，也就是说int a1 = 127时,在范围之内，这个时候就存放在缓存中，当再创建a2时，java发现缓存中存在127这个数了，就直接取出来赋值给a2，所以a1 == a2的。当超过范围就是new Integer()来new一个对象了，所以c、d都是new Integer(128)出来的变量，所以它们不等。","categories":[],"tags":[]},{"title":"滑动窗口","slug":"滑动窗口","date":"2022-03-26T04:56:05.674Z","updated":"2022-03-30T02:09:37.932Z","comments":true,"path":"滑动窗口/","link":"","permalink":"http://bionic-sheep.github.io/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"","text":"滑动窗口不断的调节子序列的起始位置和终止位置，得到我们想要的结果。 一般的模板： 12345for(枚举选择) 右边界 while(窗口条件) 左边界 更新结果 下面给出一种更常用的模板 1234567891011121314151617181920212223242526272829//1.需要维护的变量，长度大小，数和，哈希表等int sum, Map。。。//2.定义首尾端int left = 0, right = 0while(right &lt; len)&#123;//3.更新维护的变量sum +=, map.put.. //4.下面有两种情况，一种是长度可变的窗口，一种是长度固定的窗口//4.1长度可变，一般是在3更新维护变量时，破坏了窗口的合法性，//需要在while中，更改维护的变量并且左移指针来恢复窗口的合法性while(长度可变)&#123; sum -= nums[left]; left++;&#125;//4.2长度不可变，一般是在满足条件后，用if判断当前窗口是否达到限定长度，//然后左指针迁移一个单位，保证下次右指针右移，窗口长度不变if(长度不变)&#123; left++;&#125;//5.更新答案，一般求法都是求解窗口的最大长度，不是必要步骤，但很常见ans = Math.max(ans, right - left);right++;&#125;//返回答案 209. 长度最小的子数组123456789101112131415161718192021public int minSubArrayLen(int target, int[] nums) &#123; //滑动窗口：右边界走，满足条件在while里处理左边界 int tmp = 0; // step1:定义需要维护的变量，tmp，变量和 int left = 0, right = 0; //step2:窗口的首尾两端 int len = nums.length; int ans = len+1; while(right &lt; len)&#123; tmp += nums[right]; //step3:更新维护的变量 //step4情况1：窗口长度固定：用if语句判断当前窗口是否达到了限定长度， // 达到了，窗口左指针前移一个单位，来保证下一次右指针右移时，窗口长度不变， while(tmp &gt;= target)&#123; //step4情况2：窗口长度可变：当前窗口不合法，tmp和大于目标值， // 用while不断的移动左指针剔除非法元素直至窗口合法，在左指针移动前更新维护的变量 ans = Math.min(right - left, ans); //因为这是求最小，left = 0, right = 0,那么最小的就是0，所以放在while里面合适 tmp -= nums[left]; left++; &#125; &#125; return ans; &#125; 904. 水果成篮12345678910111213141516public int totalFruit(int[] fruits) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); //维护的变量，维护摘下的水果不超过2个 int left = 0, right = 0; int ans = 0; while(right &lt; fruits.length)&#123; map.put(fruits[right], map.getOrDefault(fruits[right], 0) + 1); //更新维护变量：放入水果 while(map.size() &gt; 2)&#123; //判断是否超过窗口条件，长度不固定，这里的窗口长度是两种水果相连的长度，不是两种水果是窗口，所以是可变的 map.put(fruits[left], map.get(fruits[left])-1); //更新维护变量 if(map.get(fruits[left]) == 0) map.remove(fruits[left]); left++; //左指针左移，然后不断的更新维护变量，来破坏窗口的非法性 &#125; ans = Math.max(right - left + 1, ans); //更新答案 right++; &#125; return ans;&#125; 3. 无重复字符的最长子串123456789101112131415161718public int lengthOfLongestSubstring(String s) &#123; //用一个map装字符，当在遍历过程中， //发现map中有这个字符，表示重复了，将左指针定位到该字符的位置，每次遍历的过程比较ans大小 Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); //更新维护变量 int left = 0, right = 0; //首尾 int len = s.length(); int ans = 0; while(right &lt; len)&#123; char c = s.charAt(right); if(map.containsKey(c))&#123; //长度固定:重复子串的长度固定 left = Math.max(map.get(c), left); //这里用Math.max是因为可能出现在left前的位置出现重复字符，但是left不能往左移， &#125; map.put(c, right+1); //更新维护变量 ans = Math.max(ans, right-left+1); right++; &#125; return ans;&#125; 424. 替换后的最长重复字符1234567891011121314151617181920public int characterReplacement(String s, int k) &#123; //难点在于：窗口条件是什么！ 总字符数 - 最多次字符数 &lt;= k 为合法 int[] arr = new int[26]; int left = 0, right = 0; int max = 0; int ans = 0; while(right &lt; s.length())&#123; char c = s.charAt(right); //找最多的字符数的 arr[c - &#x27;A&#x27;]++; // 找维持窗口条件的最多次字符数 max = Math.max(max, arr[c - &#x27;A&#x27;]); while(right - left + 1 - max &gt; k)&#123; //长度可变 arr[s.charAt(left) - &#x27;A&#x27;]--; //移除最左边元素的字符，如果是最多次字符，下次继续缩短窗口，如果是其他字符，下次增大窗口 left++; //左移，恢复窗口合法性， &#125; right++; ans = Math.max(ans, right-left); //因为是可变长的滑动窗口，保存历史中最大窗口长度 &#125; return ans;&#125; 1493. 删掉一个元素以后全为 1 的最长子数组1234567891011121314public int longestSubarray(int[] nums) &#123; int left = 0, right = 0; int k = 0, ans = 0; //k是维护变量，长度 while(right &lt; nums.length)&#123; if(nums[right] == 0) ++k; //更新维护变量 while(k &gt; 1)&#123; if(nums[left] == 0) --k; left++; //左移，直至找到更改维护变量的下标 &#125; right++; ans = Math.max(ans, right- left-1); &#125; return ans;&#125; 978. 最长湍流子数组376摆动序列的变形。思路也来自于此 1234567891011121314151617181920public int maxTurbulenceSize(int[] arr) &#123; int pre = 0, cur = 0; //维护变量 int left = 0, right = 1; int len = arr.length; if(len &lt; 2) return len; int ans = 1; while(right &lt; len)&#123; pre = arr[right] - arr[right-1]; //小于0，前是山峰，大于0，前是低谷，等于0，为平路 if((cur &gt; 0 &amp;&amp; pre &gt; 0) || (cur &lt; 0 &amp;&amp; pre &lt; 0))&#123; //不满足条件，左边界右移右指针左边 left = right-1; &#125; if(pre == 0) left = right; //不满足条件：左边界右移到右指针 cur = pre; //更新维护变量 ans = Math.max(ans, right - left+1); right++; &#125; return ans;&#125; 下面给出思路相似的三个题 都是在一个字符串s找另一个字符串t相关性，其中438和567是一样的题，只是叫法不一样，而76则是它们的升级版 438. 找到字符串中所有字母异位词1234567891011121314151617181920212223242526public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); //本题思路很好想，不停的拿p长度的s子串与p对比，难点在于，使用什么样的结构 int sLen = s.length(); int pLen = p.length(); if(sLen &lt; pLen) return ans; int[] sCount = new int[26]; //维护的变量：哈希表sCount, pCount不算是维护变量，只是起一个与窗口元素对比的作用 int[] pCount = new int[26]; for(int i = 0; i &lt; pLen; ++i)&#123; sCount[s.charAt(i) - &#x27;a&#x27;]++; pCount[p.charAt(i) - &#x27;a&#x27;]++; &#125; if(Arrays.equals(sCount, pCount))&#123; ans.add(0); &#125; for(int i = 0; i &lt; sLen - pLen; ++i)&#123; sCount[s.charAt(i) - &#x27;a&#x27;]--; // 去掉左指针的元素，左指针和右指针是一个指针，共同移动 窗口后移，例如ecbauuuucba ,sCount现在是ecb，去掉e加入cba，这样就对比成功了 sCount[s.charAt(i+pLen) - &#x27;a&#x27;]++; if(Arrays.equals(sCount, pCount))&#123; //这种双哈希表的做法好处就是节省了两子串比较的成本，直接比较哈希表是否相等即可 ans.add(i+1); &#125; &#125; return ans;&#125; 567. 字符串的排列同上一题 123456789101112131415161718public boolean checkInclusion(String s1, String s2) &#123; int[] sC = new int[26]; int[] pC = new int[26]; int len1 = s1.length(), len2 = s2.length(); if(len1 &gt; len2) return false; for(int i = 0; i &lt; len1; ++i)&#123; sC[s1.charAt(i) - &#x27;a&#x27;]++; pC[s2.charAt(i) - &#x27;a&#x27;]++; &#125; if(Arrays.equals(sC, pC)) return true; for(int i = 0; i &lt; len2 - len1; ++i)&#123; pC[s2.charAt(i) - &#x27;a&#x27;]--; pC[s2.charAt(i+len1) - &#x27;a&#x27;]++; if(Arrays.equals(sC, pC)) return true; &#125; return false;&#125; 76. 最小覆盖子串本题是前两题的升级版：也是双哈希表，只是采用了双map 12345678910111213141516171819202122232425262728293031323334353637383940414243//public String minWindow(String s, String t) &#123; //map元素 //维护的变量：窗口，这个窗口会加入两种变量，实变量与虚变量 //实变量：tMap中含有的元素，虚变量：tMap不含有的元素。 //这里新增两个概念只是为了让滑动窗口更好理解一点。 Map&lt;Character, Integer&gt; sMap = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; tMap = new HashMap&lt;&gt;(); //起到对比作用 for(char c : t.toCharArray())&#123; tMap.put(c, tMap.getOrDefault(c, 0)+1); &#125; int left = 0, right = 0; int match = 0; int len = s.length()+1; int[] ans = new int[2]; while(right &lt; s.length())&#123; char c = s.charAt(right); if(tMap.containsKey(c))&#123; //判断tMap中是否含有实变量 sMap.put(c, sMap.getOrDefault(c, 0) + 1); //更新维护变量：添加实变量 if(sMap.get(c).equals(tMap.get(c)))&#123; match++; //窗口合法性破坏 &#125; &#125; while(match == tMap.size())&#123; //表示窗口的元素全部集齐 if(right - left &lt; len)&#123; //寻找下标 这里是找答案 ans[0] = left; ans[1] = right+1; len = right - left; &#125; char c1 = s.charAt(left); if(sMap.getOrDefault(c1, 0) != 0)&#123; //不是虚变量，即移除实变量 sMap.put(c1, sMap.get(c1)-1); //移除实变量 if(sMap.get(c1) &lt; tMap.get(c1))&#123; match--; &#125; &#125; left++; //左移指针，移除虚变量 &#125; right++; //right每一次右移，相当于将虚变量添加入了sMap中 &#125; return s.substring(ans[0], ans[1]); &#125;","categories":[],"tags":[]},{"title":"双指针","slug":"双指针","date":"2022-03-25T13:44:19.947Z","updated":"2022-03-30T02:11:32.863Z","comments":true,"path":"双指针/","link":"","permalink":"http://bionic-sheep.github.io/%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"双指针：顾名思义在遍历对象的过程中，使用两个指针进行扫描，达成相应目的 常见的双指针两种：快慢指针和左右指针。 快慢指针一般应用于滑动窗口，左右指针一般应用于二分查找。数据结构一般常见于数组、字符串和链表。 快慢指针同方向遍历，slow指向待处理的位置，fast指向待处理的元素，下面给出三个思路一模一样的简单题 27. 移除元素123456789101112public int removeElement(int[] nums, int val) &#123; int len = nums.length; int slow = 0, fast = 0; while(fast &lt; nums.length)&#123; if(nums[fast] != val)&#123; //fast指向待处理的元素，判断是不是val，不是，赋值到slow位置上 nums[slow] = nums[fast]; slow++; &#125; fast++; &#125; return slow;&#125; 26. 删除有序数组中的重复项1234567891011public int removeDuplicates(int[] nums) &#123; int slow = 0, fast = 0; while(fast &lt; nums.length)&#123; if(nums[slow] != nums[fast])&#123; //fast找不相等元素 slow++; //形成错位 nums[slow] = nums[fast]; &#125; fast++; &#125; return slow+1; &#125; 283. 移动零123456789101112131415public void moveZeroes(int[] nums) &#123; int slow = 0, fast = 0; while(fast &lt; nums.length)&#123; if(nums[fast] != 0)&#123; //找不是0的元素，然后给slow处理 swap(nums, slow, fast); slow++; &#125; fast++; &#125;&#125;public void swap(int[] nums, int i, int j)&#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;&#125; 上面三个题思路都是相似的，fast负责先走，找到待处理的元素，slow负责待着原地，等着fast找到元素，fast找到后，处理好元素，slow才继续往后走。 下面给出进阶二分查找，但里面的思路和上面是一样的，可能多了其他约束 611. 有效三角形的个数注意下面7-14行，和上面思想是一样的，fast往后走，找到右边界（或者说某个值），然后回来处理，处理结束后，slow++，即 123456789101112131415161718public int triangleNumber(int[] nums) &#123; //双指针：用i固定住，j,k则是双指针移动，和三数之和类似 int len = nums.length; int ans = 0; Arrays.sort(nums); for(int i = 0; i &lt; len - 2; ++i)&#123; int fast = i+1; //将fast放在这，是因为当slow++向后移，fast不可能重新从slow+1开始遍历，因为随着slow增加，前面的数肯定 //会继续算在ans里，所以，fast继续在老位置向后遍历。或者记住我们是查找范围不是查找值即可 for(int slow = i+1; slow &lt; len - 1; ++slow)&#123; while(fast &lt; len &amp;&amp; nums[fast] &lt; nums[slow] + nums[i])&#123; //等到fast == i + slow时，就不满足条件了 fast++; &#125; ans += Math.max(fast - slow-1, 0); //[slow,fast],这个区间的数都表示第三边小于两边之和 &#125; &#125; return ans;&#125; 左右指针一般的左右指针都是二分查找，详细内容可见二分查找笔记。 下面给出三个不是二分查找的，是左右指针比较，然后进行相应的处理， 125. 验证回文串12345678910111213141516public boolean isPalindrome(String s) &#123; int left = 0, right = s.length()-1; while(left &lt; right)&#123; while(left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left)))&#123; //去掉除去不是数字或字母的 left++; &#125; while(left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right)))&#123; right--; &#125; //化成小写字母再判断 if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) return false; left++; right--; &#125; return true;&#125; 新解法：下面增加两个相似的算法 12345678910111213while(left &lt; right)&#123; while(left &lt; right)&#123; //处理left字符，直至满足题目要求 &#125; while(left &lt; right)&#123; //处理Right字符，直至满足题目要求 &#125; //比较left和左右字符 //不满足条件返回fasle&#125;return true; 125. 验证回文串12345678910111213141516171819202122232425public boolean isPalindrome(String s) &#123; int left = 0, right = s.length()-1; while(left &lt; right)&#123; while(left &lt; right)&#123; if(!Character.isLetterOrDigit(s.charAt(left)))&#123; left++; &#125;else&#123; break; &#125; &#125; while (left &lt; right)&#123; if(!Character.isLetterOrDigit(s.charAt(right)))&#123; right--; &#125;else&#123; break; &#125; &#125; if(Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right)))&#123; return false; &#125; left++; right--; &#125; return true;&#125; 844. 比较含退格的字符串12345678910111213141516171819202122232425262728293031323334353637383940public boolean backspaceCompare(String s, String t) &#123; int sLen = s.length(), tLen = t.length(); int sIndex = sLen-1, tIndex = tLen-1; int skipS = 0, skipT = 0; while(sIndex &gt;= 0 || tIndex &gt;= 0)&#123; while(sIndex &gt;= 0)&#123; if(s.charAt(sIndex) == &#x27;#&#x27;)&#123; skipS++; sIndex--; &#125;else if(skipS &gt; 0)&#123; skipS--; sIndex--; &#125;else&#123; break; &#125; &#125; while(tIndex &gt;= 0)&#123; if(t.charAt(tIndex) == &#x27;#&#x27;)&#123; skipT++; tIndex--; &#125;else if(skipT &gt; 0)&#123; skipT--; tIndex--; &#125;else&#123; break; &#125; &#125; if(sIndex &gt;= 0 &amp;&amp; tIndex &gt;= 0)&#123; if(s.charAt(sIndex) != t.charAt(tIndex))&#123; return false; &#125; &#125;else&#123; if(sIndex &gt;= 0 || tIndex &gt;= 0)&#123; return false; //表示有一个走到底了 &#125; &#125; sIndex--; tIndex--; &#125; return true; 977. 有序数组的平方123456789101112131415161718public int[] sortedSquares(int[] nums) &#123; int left = 0, right = nums.length-1; int len = nums.length; int index = len - 1; int[] arr = new int[len]; while(left &lt;= right)&#123; if(nums[left] + nums[right] &lt; 0)&#123; //表示左边绝对值更大 arr[index] = nums[left] * nums[left]; left++; &#125;else&#123; arr[index] = nums[right] * nums[right]; right--; &#125; index--; &#125; return arr;&#125; 15. 三数之和1234567891011121314151617181920212223242526272829303132public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); //排序 int len = nums.length; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; len -2; ++i)&#123; if(nums[i] &gt; 0) return ans; //当三元组第一个大于0，表示为后面不可能为0 //去重,重复的元素不能一直用 if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; int left = i+1, right = nums.length-1; while(left &lt; right)&#123; if(nums[i] + nums[left] + nums[right] &lt; 0)&#123; //表示left小了 left++; &#125;else if(nums[i] + nums[left] + nums[right] &gt; 0)&#123; right--; &#125;else&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(nums[i]); list.add(nums[left]); list.add(nums[right]); ans.add(list); while(left &lt; right &amp;&amp; nums[left] == nums[left+1]) left++; //去重 while(left &lt; right &amp;&amp; nums[right] == nums[right-1]) right--; left++; right--; &#125; &#125; &#125; return ans;&#125;","categories":[],"tags":[]},{"title":"二分查找","slug":"二分查找","date":"2022-03-22T13:05:15.905Z","updated":"2022-03-30T02:11:43.245Z","comments":true,"path":"二分查找/","link":"","permalink":"http://bionic-sheep.github.io/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"二分查找是一个高效率的查找方法，通常应用在顺序存储结构，且关键字有序。 查找过程： 将搜索空间中间的数mid与target比较 当mid数小于target说明target在搜索空间右边，将[mid+1-right]作为搜索空间，当mid数大于target说明target在搜索空间左边，将left-mid-1作为搜索空间。 重复1.2步骤，直至发现target或搜索空间为0 核心思想：不断的缩短搜索空间来寻值。 基本方法左闭右闭和左闭右开 1234567891011121314public int search(int[] nums, int target) &#123; //最简单的模板 int left = 0, right = nums.length-1; while(left &lt;= right)&#123; // [left, right] int mid = left + (right - left)/2; if(nums[mid] == target) return mid; else if(nums[mid] &gt; target)&#123; right = mid -1; //nums[mid]参与了运算，即[left, mid]结束搜索，下一个搜索空间为[mid+1,right] &#125;else&#123; left = mid + 1; //同理,[mid, right]结束搜索，下一个搜索空间为[left, mid-1] &#125; &#125; return -1; &#125; 12345678910111213public int search(int[] nums, int target) &#123; int left = 0 ,right = nums.length; while(left &lt; right)&#123; //[left, right)，因为right = nums.length 表示nums[right]是不存在的数 int mid = (left + right)/2; if(nums[mid] == target) return mid; else if(nums[mid] &lt; target)&#123; left = mid + 1; // nums[mid]参与运算，即[left, mid]结束搜索，下一个[mid+1, right) &#125;else&#123; right = mid; //同理，[mid,right)结束，下一个搜索空间是[left, mid-1],这里为了保持左闭右开的一致性，用right表示mid-1，即[left, mid-1] == [left, mid) == [left, right) &#125; &#125; return -1; &#125; 之前不太明白左闭右开的搜索逻辑，但是在LC上看了大佬liweiwei1419的文章后才算是豁然开朗。 下面给出我做的几个二分查找LC题 35. 搜索插入位置这题算是第三个模板，只有两个判断，同过不断缩短搜索空间，最后left == right跳出循环 12345678910111213public int searchInsert(int[] nums, int target) &#123; //首先弄懂它查找的值在数组中的实际意义，找到target第一次大于等于元素的下标 int left = 0, right = nums.length; while(left &lt; right)&#123; //当left和right重合，停止搜索，即left是大于或等于的元素下标 int mid = (left+right)/2; if(nums[mid] &lt; target)&#123; left = mid + 1; //[left, mid] 小于它 [mid+1, right) &#125;else&#123; right = mid; //[mid, right) &#125; &#125; return left;&#125; 34. 在排序数组中查找元素的第一个和最后一个位置123456789101112131415161718192021222324252627282930313233343536373839public int[] searchRange(int[] nums, int target) &#123; int leftBorder = getLeftBorder(nums, target); int rightBorder = getRightBorder(nums, target); if(leftBorder == -2 || rightBorder == -2) return new int[]&#123;-1,-1&#125;; //因为它不但向一边逼近 if(rightBorder - leftBorder &gt; 1) return new int[]&#123;leftBorder+1, rightBorder-1&#125;; else return new int[]&#123;-1,-1&#125;;&#125;public int getLeftBorder(int[] nums, int target)&#123; //寻找左边界,即重复元素第一个，那么右边不断向左缩短即可 int left = 0, right = nums.length; int ans = -2; while(left &lt; right)&#123; int mid = (left+right)/2; if(nums[mid] &gt;= target)&#123; //因为是右边不断向左缩小，那么必然有相等的情况 right = mid; // [mid, right) --&gt; [left, mid-1] -- &gt;[left, mid) ans = right - 1; &#125;else&#123; left = mid + 1; //[left, mid] --&gt; [mid+1, right] &#125; &#125; return ans;&#125;public int getRightBorder(int[] nums, int target)&#123; int left = 0, right = nums.length; int ans= -2; while(left &lt; right)&#123; int mid = (left+right)/2; if(nums[mid] &lt;= target)&#123; //，如果不存该数，例如nums = [5,7,7,8,8,10], target = 6，那么不会进入下面语句 //左边向右逼近， left = mid + 1; ////[left, mid] --&gt; [mid+1, right] ans = left; &#125;else&#123; right = mid; &#125; &#125; return ans;&#125; 69. x 的平方根 1234567891011121314151617public int mySqrt(int x) &#123; // 有序，找值，k² &lt;= x 中k的最大值 int left = 0, right = x; //这里不能x/2，因为x/2，因为奇偶数不同，奇数除2会向下取整数，所以成闭区间，偶数又是开区间 int ans = 1; while(left &lt;= right)&#123; int mid = left + (right-left)/2; if((long)mid*mid &lt;= x)&#123; //应该是向右逼近， ans = mid; //ans记下当前满足条件的k left = mid + 1; &#125;else&#123; right = mid - 1; &#125; &#125; return ans;&#125; 367. 有效的完全平方数1234567891011121314151617class Solution &#123; public boolean isPerfectSquare(int num) &#123; //和x一样 int left = 0, right = num; int ans = -1; while(left &lt;= right)&#123; int mid = (right-left)/2 + left; if((long)mid*mid &lt;= num)&#123; ans = mid; left = mid + 1; &#125;else&#123; right = mid - 1; &#125; &#125; return ans*ans == num; &#125;&#125; 总结上面部分我基本只写了两种判断就是为了锻炼分析搜索空间的能力。一定要记住核心思想：不断的减小搜索空间。 解题首要要判断我们到底要找的是什么样的值，有哪些特征。 比如说35.搜索插入位置，我们要找到值是一个大于等于target的元素下标。 当前左边所有的搜索空间均小于它，那么反过来，随着搜索空间的减小，mid+1是不是最终就大于等于target 12if(nums[mid] &lt; target)&#123; left = mid + 1; //[left, mid] 小于它 [mid+1, right) 同理,右边所有的搜索空间均大于等于它，那么最终left == right的时候，right就停在了大于等于target的元素下标的位置 123else&#123; right = mid; //[mid, right) &#125; 所以最后返回 left或right均可。 34,69,367问题都是类似，都是找元素下标，34左边找第一个target下标，右边找最后一个target下边，69和367是一样的问题，34找k²&lt;=x的最大值k,367找k²==x。都是逐步减小搜索空间，然后逼近。仔细体会","categories":[],"tags":[]},{"title":"ArrayList和LinkedList","slug":"ArrayList和LinkedList","date":"2022-03-20T08:06:07.746Z","updated":"2022-03-30T02:11:05.001Z","comments":true,"path":"ArrayList和LinkedList/","link":"","permalink":"http://bionic-sheep.github.io/ArrayList%E5%92%8CLinkedList/","excerpt":"","text":"Collection接口的常用方法 123456789boolean add(E e); // 向集合中添加一个元素boolean addAll(Collection c); //添加集合中的所有元素void clean(); //清理集合中所有元素，集合长度为0boolean contains(Object o); //判断集合中是否存在指定元素boolean isEmpty(); // 判空boolean remove(Object o); //删除指定元素，当集合包含多个元素o，值删除第一个符合条件的元素。int size();Object[] toArray();//转换为响应的数组boolean retainAll(); //保留集合中相同的元素，其余删除 重点 排序操作 123456void reverse(List list); //反转void shuffle(List list);//随机排序void sort(List list);//按自然排序升序void sort(List list, Comparator c); //定制排序void swap(List list, int i, int j);//交换两个索引位置的元素void rotate(List list, int distance); //旋转，当distance为正数，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面 查找、替换 1234567int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素int frequency(Collection c, Object o)//统计元素出现次数int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素 List有序、可重复的集合。 实现类：ArrayList和LinkedList ArrayList实现可变数组大小，快速基于索引访问元素的方式，即随机访问，删除和插入元素相对较慢 12345E get(int index);//获取index下标元素int index(Object o); //返回第一次出现指定元素的索引 不存在返回-1int lastIndexOf(Object o); //返回最后一次出现指定元素的索引 不存在返回-1E set(int index, E element); //将此索引位置元素修改为elements参数指定的对象List&lt;E&gt; subList(int fromIndex, int toIndex); //返回两个参数索引之间的所有元素 LinkedList采用链表保存对象，便于向集合中插入或者删除元素 123456void addFirst(E e); //将指定元素添加到此集合的开头void addLast(E e); //将指定元素添加到此集合的末尾E getFirst(); //返回首元素E getLast(); //返回尾元素E removeFirst(); //删除首元素E removeLast(); //删除为元素 ArrayList和LinkedList的区别都是List接口的实现类，都实现了List的方法，只是实现的方式不同。 ArrayList是基于动态数组数据结构实现的，在元素访问上更胜一筹，因为数组在内存上的存储是连续的，但是链表是离散的，需要根据上下游标去查询 LinkedList是基于链表数据结构实现的，占用内存空间大，但在删除和增加元素上更好，可扩展性更好。","categories":[],"tags":[]},{"title":"hexo + github 显示404 There isn't a GitHub Pages site here.","slug":"hexo + github 显示404 There isn't a GitHub Pages site here","date":"2022-03-20T05:00:07.280Z","updated":"2022-03-30T02:10:48.964Z","comments":true,"path":"hexo + github 显示404 There isn't a GitHub Pages site here/","link":"","permalink":"http://bionic-sheep.github.io/hexo%20+%20github%20%E6%98%BE%E7%A4%BA404%20There%20isn't%20a%20GitHub%20Pages%20site%20here/","excerpt":"","text":"我是按照https://www.nowcoder.com/discuss/657562?type=0&amp;order=7&amp;pos=8&amp;page=1&amp;channel=1009&amp;source_id=discuss_center_0_nctrack 这篇文章来搭建博客的，在部署的过程中一直显示错误，最后 在这反应过来了，这里的意思应该是你github的用户名，我的用户名叫bionic-sheep，但是我的仓库名叫sheep。 最后在 这个地方改过来之后就好了。 刚好当做博客的第一篇博文","categories":[],"tags":[]},{"title":"comparable 和 comparator","slug":"comparable 和 comparator","date":"2021-09-04T14:52:18.527Z","updated":"2022-03-30T02:13:05.754Z","comments":true,"path":"comparable 和 comparator/","link":"","permalink":"http://bionic-sheep.github.io/comparable%20%E5%92%8C%20comparator/","excerpt":"","text":"Comparable接口的 - 自然排序 像String 、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式 重写compareTo(obj)规则 对于自定义类来说，如果需要排序： 首先实现 Comparable接口 其次重写CompareTo(obj)方法 //String、包装类的排序：不需要自己重写compareTo(obj)方法。类已经写好了 123456789@Test public void test1()&#123; String[] arr = new String[]&#123;&quot;AA&quot;, &quot;CC&quot;, &quot;KK&quot;, &quot;MM&quot;, &quot;GG&quot;&#125;; Arrays.sort(arr); System.out.println(Arrays.toString(arr)); &#125; //自定义类：需要自己重写 12345678910111213141516171819202122232425262728293031323334353637public class CompareTest &#123;@Test public void test2()&#123; Goods[] arr = new Goods[4]; arr[0] = new Goods(&quot;apple&quot;, 34); arr[1] = new Goods(&quot;xiaomi&quot;, 12); arr[2] = new Goods(&quot;huawei&quot;, 24); arr[3] = new Goods(&quot;lenven&quot;,22); Arrays.sort(arr); System.out.println(Arrays.toString(arr)); &#125;&#125;public class Goods implements Comparable&#123; ...//省略类的属性、构造方法、getset方法 //重写compareTo(obj)方法 @Override public int compareTo(Object o) &#123; if( o instanceof Goods)&#123;//强转 Goods goods =(Goods)o; if(this.price &lt; goods.price)&#123; return 1; //返回正数 goods更大 &#125;else if(this.price &gt; goods.price)&#123; return -1; &#125;else&#123; return 0; &#125; //方式二 // return Double.compare(this.price, goods.price); &#125; throw new RuntimeException(&quot;传入的数据类型不一致！&quot;); &#125; &#125; 快捷键alt ＋ insert 可以插入构造器。get set toString equals等方法 Comparato接口-定制排序 背景：当元素的类型没有实现java.lang.Comparable接口但又不方便修改代码，或者当前接口的排序规则不符合当前操作，就使用Comparato的对象来排序 重写compare(Object o1, Object o2)方法，比较o1和o2的大小：如果方法返回正整数，o1 大于 o2; 0 则相等 否则o1 小于 o2 12345678910111213141516171819@Test public void test3()&#123; String[] arr = new String[]&#123;&quot;AA&quot;, &quot;CC&quot;, &quot;KK&quot;, &quot;MM&quot;, &quot;GG&quot;&#125;; Arrays.sort(arr, new Comparator&lt;String&gt;() &#123; //自定义排序 //按照字符串从大到小排序 @Override public int compare(String o1, String o2) &#123; if(o1 instanceof String &amp;&amp; o2 instanceof String)&#123;//强转数据类型 String s1 = (String) o1; String s2 = (String) o2; return -s1.compareTo((s2)); &#125; throw new RuntimeException(&quot;输入类型不一致！&quot;); &#125; &#125;); System.out.println(Arrays.toString(arr)); &#125; 12345678910111213141516171819202122232425262728293031//自定义类@Test public void test4()&#123; Goods[] arr = new Goods[6]; arr[0] = new Goods(&quot;apple&quot;, 34); arr[1] = new Goods(&quot;xiaomi&quot;, 12); arr[2] = new Goods(&quot;huawei&quot;, 34); arr[3] = new Goods(&quot;lenven&quot;,22); arr[4] = new Goods(&quot;lenven&quot;,223); arr[5] = new Goods(&quot;lenven1&quot;,12); Arrays.sort(arr, new Comparator&lt;Goods&gt;() &#123; //按照产品名称从低到高排序，再按价格从高到低 @Override public int compare(Goods o1, Goods o2) &#123; if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods)&#123; Goods g1 = (Goods) o1; Goods g2 = (Goods) o2; if(g1.getName().equals(g2.getName()))&#123; //品牌一样 return -Double.compare(g1.getPrice(), g2.getPrice()); &#125;else&#123; return g1.getName().compareTo((g2.getName())); &#125; &#125; throw new RuntimeException(&quot;数据类型输入错误！&quot;); &#125; &#125;); System.out.println(Arrays.toString(arr)); &#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}